const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BaZ9ZXQ8.js","assets/Bridge.js","assets/index.js","assets/index.BvO5tclL.css","assets/index-Dlnoph5j.js"])))=>i.map(i=>d[i]);
import{bu as p}from"./index.js";import{n as I,o as A,aS as c,p as C,aT as y,r as T,s as h,aU as f,t as E,w as x,c as R,aV as w,z as j,aW as k,aX as S}from"./Bridge.js";var $=Object.defineProperty,D=(e,o,t)=>o in e?$(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t,m=(e,o,t)=>D(e,typeof o!="symbol"?o+"":o,t);class v extends j{}const b=class l extends I{constructor(o,t){super(o,t??A(o,l._platform))}getRpc(o){if(o in this.config)return new c.Algodv2("",this.config[o].rpc);throw new Error("No configuration available for chain: "+o)}getChain(o){if(o in this.config)return new v(o,this);throw new Error("No configuration available for chain: "+o)}static nativeTokenId(o,t){if(!l.isSupportedChain(t))throw new Error(`invalid chain for Algorand: ${t}`);return C.chainAddress(t,y)}static isNativeTokenId(o,t,n){return!l.isSupportedChain(t)||n.chain!==t?!1:this.nativeTokenId(o,t)==n}static isSupportedChain(o){return T(o)===l._platform}static async getDecimals(o,t,n){const s=h(n)?0:new f(n).toInt();if(s===0)return E(l._platform);const i=await t.getAssetByID(s).do(),a=c.modelsv2.Asset.from_obj_for_encoding(i);if(!a.params||!a.params.decimals)throw new Error("Could not fetch token details");return Number(a.params.decimals)}static async getBalance(o,t,n,s){const i=h(s)?0:new f(s).toInt();if(i===0){const u=await t.accountInformation(n).do(),d=c.modelsv2.Account.from_obj_for_encoding(u);return BigInt(d.amount)}const a=await t.accountAssetInformation(n,i).do(),r=c.modelsv2.AssetHolding.from_obj_for_encoding(a);return BigInt(r.amount)}static async getBalances(o,t,n,s){let i;if(s.includes("native")){const a=await t.accountInformation(n).do(),r=c.modelsv2.Account.from_obj_for_encoding(a);i=BigInt(r.amount)}return s.map(async a=>{if(h(a))return{native:i};const r=new f(a).toInt(),u=await t.accountAssetInformation(n,r).do(),d=c.modelsv2.AssetHolding.from_obj_for_encoding(u);return BigInt(d.amount)}).reduce((a,r)=>Object.assign(a,r),{})}static async sendWait(o,t,n){const s=n.map((r,u)=>c.decodeSignedTransaction(r)).map((r,u)=>r.txn.txID()),{txId:i}=await t.sendRawTransaction(n).do();if(!i)throw new Error("Transaction(s) failed to send");const a=await c.waitForConfirmation(t,i,4);if(!c.modelsv2.PendingTransactionResponse.from_obj_for_encoding(a).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return s}static async getLatestBlock(o){const t=await o.status().do(),n=c.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!n.lastRound)throw new Error("Error getting status from node");return Number(n.lastRound)}static async getLatestFinalizedBlock(o){const t=await o.status().do(),n=c.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!n.lastRound)throw new Error("Error getting status from node");return Number(n.lastRound)}static chainFromChainId(o){const t=x(l._platform,o);if(t===void 0)throw new Error(`Unknown native chain id ${o}`);const[n,s]=t;return[n,s]}static async chainFromRpc(o){const t=await o.versionsCheck().do(),n=c.modelsv2.Version.from_obj_for_encoding(t);return this.chainFromChainId(n.genesisId)}};m(b,"_platform",w);let _=b;async function N(e,o){const[t,n]=await _.chainFromRpc(e);return new B(n,e,o)}class B{constructor(o,t,n,s=!1){m(this,"_chain"),m(this,"_debug"),m(this,"_account"),this._chain=o,this._debug=s,this._account=k(n)}chain(){return this._chain}address(){return this._account.addr}async sign(o){const t=[],n=o.map((a,r)=>a.transaction.tx),s=S(n),i=o.map((a,r)=>(a.transaction.tx=s[r],a));for(const a of i){const{description:r,transaction:u}=a,{tx:d,signer:g}=u;this._debug&&(console.log(d._getDictForDisplay()),console.log(d.txID())),g?(this._debug&&console.log(`Signing: ${r} with signer ${g.address} for address ${this.address()}`),t.push(await g.signTxn(d))):(this._debug&&console.log(`Signing: ${r} without signer for address ${this.address()}`),t.push(d.signTxn(this._account.sk)))}return t}}const P={Address:f,Platform:_,getSigner:N,protocols:{WormholeCore:()=>p(()=>import("./index-BaZ9ZXQ8.js"),__vite__mapDeps([0,1,2,3])).then(e=>e.i),TokenBridge:()=>p(()=>import("./index-Dlnoph5j.js"),__vite__mapDeps([4,0,1,2,3]))},getChain:(e,o,t)=>new v(o,new _(e,R(e,w,{[o]:t})))},L=Object.freeze(Object.defineProperty({__proto__:null,default:P},Symbol.toStringTag,{value:"Module"}));export{_ as A,L as a};
