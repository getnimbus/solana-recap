import{C as d}from"./cosmwasm-DY1PMAJO.js";import{cI as l,bG as w,l as h,bS as p,ax as u}from"./Bridge.js";import"./index.js";import"./pbkdf2-BTEK0Lcd.js";import"./keccak-OTA2ssQD.js";import"./index-Dtqiiobd.js";var g=Object.defineProperty,f=(i,e,r)=>e in i?g(i,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):i[e]=r,m=(i,e,r)=>f(i,typeof e!="symbol"?e+"":e,r);class a{constructor(e,r,s,t){m(this,"network"),m(this,"chain"),m(this,"rpc"),m(this,"contracts"),m(this,"coreAddress"),this.network=e,this.chain=r,this.rpc=s,this.contracts=t;const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.coreAddress=o}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,r){const[s,t]=await d.chainFromRpc(e),o=r[t];if(o.network!==s)throw new Error(`Network mismatch: ${o.network} != ${s}`);return new a(s,t,e,o.contracts)}async*publishMessage(e,r,s,t){throw new Error("Method not implemented.")}async*verifyMessage(e,r){throw new Error("Not implemented.")}async parseTransaction(e){const r=await this.rpc.getTx(e);if(!r)throw new Error("No transaction found for txid: "+e);return[a.parseWormholeMessageId(this.chain,this.coreAddress,r)]}async parseMessages(e){const r=await this.rpc.getTx(e);if(!r)throw new Error("No transaction found for txid: "+e);return[a.parseWormholeMessage(this.chain,this.coreAddress,r)]}static parseWormholeMessage(e,r,s){const t=s.events.filter(n=>n.type==="wasm"&&n.attributes[0].key==="_contract_address"&&n.attributes[0].value===r);if(t.length===0)throw new Error("No wormhole message found in tx");t.length>1&&console.error(`Expected single message, found ${t.length}`);const[o]=t,c=Object.fromEntries(o.attributes.map(n=>[n.key.split(".")[1],n.value]));return l("Uint8Array",{emitterChain:e,emitterAddress:new w(h.decode(c.sender)),sequence:BigInt(c.sequence),guardianSet:0,timestamp:Number(c.block_time),consistencyLevel:0,nonce:Number(c.nonce),signatures:[],payload:h.decode(c.message)})}static parseWormholeMessageId(e,r,s){const t=a.parseWormholeMessage(e,r,s);return{chain:t.emitterChain,emitter:t.emitterAddress,sequence:t.sequence}}}p(u,"WormholeCore",a);export{a as CosmwasmWormholeCore};
