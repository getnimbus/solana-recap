import{d6 as T,d7 as y,ci as E,at as G,aq as l,s as re,l as v,d8 as Z,d9 as h,da as se,L as _,db as oe,m as ie,bS as ce,aU as O,dc as L,dd as X,de,df as z,cI as pe,dg as ge,dh as ue,di as J,bI as he,bJ as le}from"./Bridge.js";import{A as fe}from"./algorand-DGFW1DOS.js";import"./index.js";var Ae=Object.defineProperty,me=(a,e,t)=>e in a?Ae(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,c=(a,e,t)=>me(a,typeof e!="symbol"?e+"":e,t);class ye{constructor(e,t,r,n,s=!1){c(this,"transaction"),c(this,"network"),c(this,"chain"),c(this,"description"),c(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=s}}const Q=1002e3,j=15,V=127,Y=8,N=V*Y,ee=V*j,$=Y*ee,b={_limit:127,encodingLength:a=>{let e=0;for(;a>=128;e++)a>>=7;return e+1},encode:(a,e,t)=>{if(typeof a=="bigint"&&(a=h(a)),a<0)throw new RangeError("value must be unsigned");const r=b.encodingLength(a);if(e=e||new ArrayBuffer(r),t=t||0,e.byteLength<t+r)throw new RangeError("the buffer is too small to encode the number at the offset");const n=new Uint8Array(e,t);let s=0;for(;b._limit<a;)n[s++]=a&b._limit|128,a>>=7;return n[s]=Number(a),n},decode:(a,e=0)=>{let t=0,r=0,n;do{if(n=a[e+r],n===void 0)throw new RangeError("offset out of range");t+=(n&b._limit)<<r*7,r++}while(128<=n);return t}},g={forMessageId:(a,e)=>{const t=T(y(a)).publicKey,r=e.emitter.toUniversalAddress().toUint8Array(),n=E.toBytes(BigInt(G(e.chain)),2),s=l.concat(n,r);return g.fromData({appId:a,appAddress:t,idx:e.sequence/BigInt($),address:s})},forWrappedAsset:(a,e)=>{if(re(e.address))throw new Error("native asset cannot be a wrapped asset");const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:BigInt(G(e.chain)),address:e.address.toUniversalAddress().toUint8Array()})},forNativeAsset:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:e,address:l.encode("native")})},forGuardianSet:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:BigInt(e),address:l.encode("guardian")})},forEmitter:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:0n,address:e})},_encode:a=>typeof a=="bigint"?[v.encode(b.encode(a))]:[v.encode(b.encode(a.length)),v.encode(a)],fromData:a=>{const e=["0620010181",...g._encode(a.idx),"4880",...g._encode(a.address),"483110810612443119221244311881",...g._encode(a.appId),"1244312080",...g._encode(a.appAddress),"124431018100124431093203124431153203124422"],t=v.decode(e.join(""));return new Z(t)},decodeLocalState:async(a,e,t)=>{let r;try{const o=await a.accountApplicationInformation(t,h(e)).do();r=se.from_obj_for_encoding(o).appLocalState}catch{return new Uint8Array}const n=_.encode("meta");let s=new Map;for(const o of r.keyValue){if(o.key===n)continue;const p=_.decode(o.key)[0],u=_.decode(o.value.bytes);s.set(p,u)}const i=[];for(let o=0;o<j;o++)s.has(o)&&i.push(s.get(o));return l.concat(...i)},checkBitsSet:async(a,e,t,r)=>{let n=!1,s;const i=await a.accountInformation(t).do(),o=oe.from_obj_for_encoding(i).appsLocalState;if(o&&o.forEach(I=>{BigInt(I.id)===e&&(s=I.keyValue)}),s?.length===0)return n;const p=BigInt($),u=BigInt(8),A=r/p*p,w=h(r-A),x=Math.floor(w/N),k=Math.floor((w-x*N)/8),S=_.encode(E.toBytes(x,1));return s?.forEach(I=>{if(I.key===S){const M=ie.Buffer.from(I.value.bytes,"base64"),P=1<<h(r%u);n=(M[k]&P)!=0;return}}),n},storageAccountExists:async(a,e,t)=>{try{const r=await a.accountApplicationInformation(e,h(t)).do();return Object.keys(r).length>0}catch{}return!1}},m=class d{constructor(e,t,r,n){if(c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreAppId"),c(this,"coreAppAddress"),c(this,"tokenBridgeAppId"),c(this,"tokenBridgeAppAddress"),this.network=e,this.chain=t,this.connection=r,this.contracts=n,this.chainId=G(t),!n.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const s=BigInt(n.coreBridge);if(this.coreAppId=s,this.coreAppAddress=y(s),!n.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const i=BigInt(n.tokenBridge);this.tokenBridgeAppId=i,this.tokenBridgeAppAddress=y(i)}getGuardianSet(e){throw new Error("Method not implemented.")}async*verifyMessage(e,t,r){const n=new O(e).toString(),s=await d.submitVAAHeader(this.connection,this.coreAppId,r??this.coreAppId,t,n);for(const i of s.txs)yield this.createUnsignedTx(i,"Core.verifyMessage")}static async fromRpc(e,t){const[r,n]=await fe.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} !== ${r}`);return new d(r,n,e,s.contracts)}async*publishMessage(e,t){const r=new O(e),n=r.toString(),s=await this.connection.getTransactionParams().do(),i=g.forEmitter(this.coreAppId,r.toUint8Array()),{accounts:o,txs:p}=await d.maybeCreateStorageTx(this.connection,n,this.coreAppId,i,s);for(const A of p)yield this.createUnsignedTx(A,"Core.publishMessage",!0);const u=L({from:n,appIndex:h(this.coreAppId),appArgs:[d.publishMessage,t,E.toBytes(0n,8)],accounts:o,onComplete:X.NoOpOC,suggestedParams:s});yield this.createUnsignedTx({tx:u},"Core.publishMessage",!0)}async getMessageFee(){var e;const t=await this.connection.getApplicationByID(h(this.coreAppId)).do(),r=(e=de.from_obj_for_encoding(t).params.globalState)==null?void 0:e.find(n=>n.key===d.feeKey);return r?BigInt(r.value.uint):0n}async getGuardianSetIndex(){throw new Error("Not implemented")}async parseTransaction(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=z.from_obj_for_encoding(t);return this.parseTx(r).map(n=>({chain:n.emitterChain,emitter:n.emitterAddress,sequence:n.sequence}))}async parseMessages(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=z.from_obj_for_encoding(t);return this.parseTx(r)}parseTx(e){const t=[];if(e.innerTxns&&e.innerTxns.length>0&&t.push(...e.innerTxns.flatMap(p=>this.parseTx(p))),BigInt(e.txn.txn.apid??0)!==this.coreAppId||!e.logs||e.logs.length===0)return t;const r=e.txn.txn.apaa??[];if(r.length!==3||!l.equals(new Uint8Array(r[0]),d.publishMessage))return t;const n=E.decode(e.logs[0]),s=new O(e.txn.txn.snd).toUniversalAddress(),i=new Uint8Array(r[1]),o=E.decode(r[2]);return t.push(pe("Uint8Array",{emitterChain:this.chain,emitterAddress:s,sequence:n,guardianSet:0,timestamp:0,consistencyLevel:0,nonce:Number(o),payload:i,signatures:[]})),t}static async maybeCreateStorageTx(e,t,r,n,s){const i=y(r),o=n.address(),p=[];if(await g.storageAccountExists(e,o,r))return{accounts:[o],txs:p};s=s??await e.getTransactionParams().do();const u=ge({from:t,to:o,amount:Q,suggestedParams:s});u.fee=u.fee*2,p.push({tx:u});const A=ue({from:o,appIndex:h(r),rekeyTo:i,suggestedParams:s});return A.fee=0,p.push({tx:A,signer:{address:n.address(),signTxn:w=>Promise.resolve(J(w,n).blob)}}),{accounts:[o],txs:p}}static async submitVAAHeader(e,t,r,n,s,i){i=i??await e.getTransactionParams().do();let o=[];const p=g.forMessageId(r,{chain:n.emitterChain,sequence:n.sequence,emitter:n.emitterAddress}),{accounts:u,txs:A}=await d.maybeCreateStorageTx(e,s,r,p,i);o.push(...A);const w=g.forGuardianSet(t,n.guardianSet),{accounts:[x],txs:k}=await d.maybeCreateStorageTx(e,s,t,w,i);o.push(...k);let S=[...u,x];const I=await g.decodeLocalState(e,t,x),M=he(n.hash),P=n.signatures.length,K=Math.ceil(P/d.MAX_SIGS_PER_TXN),R=20,D=new Z(d.ALGO_VERIFY);for(let C=0;C<K;C++){const F=C*d.MAX_SIGS_PER_TXN,B=n.signatures.slice(F,F+d.MAX_SIGS_PER_TXN),ne=B.length*R,q=new Uint8Array(ne);for(let f=0;f<B.length;f++){const W=B[f],ae=I.slice(W.guardianIndex*R+1,(W.guardianIndex+1)*R+1);q.set(ae,f*20)}const H=L({appArgs:[d.verifySigs,l.concat(...B.map(f=>l.concat(new Uint8Array([f.guardianIndex]),f.signature.encode()))),q,M],accounts:S,appIndex:h(t),from:d.ALGO_VERIFY_HASH,onComplete:X.NoOpOC,suggestedParams:i});H.fee=0,o.push({tx:H,signer:{address:D.address(),signTxn:f=>Promise.resolve(J(f,D).blob)}})}const U=L({appArgs:[d.verifyVaa,le(n)],accounts:S,appIndex:h(t),from:s,onComplete:X.NoOpOC,suggestedParams:i});return U.fee=U.fee*(2+K),o.push({tx:U}),{accounts:S,txs:o}}createUnsignedTx(e,t,r=!0){return new ye(e,this.network,this.chain,t,r)}};c(m,"MAX_SIGS_PER_TXN",6),c(m,"ALGO_VERIFY_HASH","EZATROXX2HISIRZDRGXW4LRQ46Z6IUJYYIHU3PJGP7P5IQDPKVX42N767A"),c(m,"ALGO_VERIFY",new Uint8Array([6,32,4,1,0,32,20,38,1,0,49,32,50,3,18,68,49,1,35,18,68,49,16,129,6,18,68,54,26,1,54,26,3,54,26,2,136,0,3,68,34,67,53,2,53,1,53,0,40,53,240,40,53,241,52,0,21,53,5,35,53,3,35,53,4,52,3,52,5,12,65,0,68,52,1,52,0,52,3,129,65,8,34,88,23,52,0,52,3,34,8,36,88,52,0,52,3,129,33,8,36,88,7,0,53,241,53,240,52,2,52,4,37,88,52,240,52,241,80,2,87,12,20,18,68,52,3,129,66,8,53,3,52,4,37,8,53,4,66,255,180,34,137])),c(m,"feeKey",_.encode("MessageFee")),c(m,"verifyVaa",l.encode("verifyVAA")),c(m,"verifySigs",l.encode("verifySigs")),c(m,"publishMessage",l.encode("publishMessage"));let te=m;ce("Algorand","WormholeCore",te);const xe=Object.freeze(Object.defineProperty({__proto__:null,AlgorandWormholeCore:te,BITS_PER_BYTE:Y,BITS_PER_KEY:N,MAX_BITS:$,MAX_BYTES:ee,MAX_BYTES_PER_KEY:V,MAX_KEYS:j,SEED_AMT:Q,StorageLogicSig:g,varint:b},Symbol.toStringTag,{value:"Module"}));export{te as A,g as S,ye as a,xe as i};
