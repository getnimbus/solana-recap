import{at as c,cI as h,O as d,bS as m}from"./Bridge.js";import{S as p}from"./sui-BZ3grhrf.js";import"./index.js";import"./pbkdf2-BTEK0Lcd.js";var w=Object.defineProperty,l=(a,e,t)=>e in a?w(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,o=(a,e,t)=>l(a,typeof e!="symbol"?e+"":e,t);class i{constructor(e,t,s,n){o(this,"network"),o(this,"chain"),o(this,"provider"),o(this,"contracts"),o(this,"chainId"),o(this,"coreBridgePackageId"),this.network=e,this.chain=t,this.provider=s,this.contracts=n,this.chainId=c(t);const r=n.coreBridge;if(!r)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=r}getGuardianSet(e){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[s,n]=await p.chainFromRpc(e),r=t[n];if(r.network!==s)throw new Error(`Network mismatch: ${r.network} !== ${s}`);return new i(s,n,e,r.contracts)}async*verifyMessage(e,t){throw new Error("Method not implemented.")}async*publishMessage(e,t){throw new Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(t=>({emitter:t.emitterAddress,sequence:t.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw new Error("Method not implemented.")}async parseMessages(e){var t;const s=(t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events)==null?void 0:t.filter(n=>n.type.endsWith("WormholeMessage"));if(!s||s.length==0)throw new Error("WormholeMessage not found");return s.map(n=>{const r=n.parsedJson;return h("Uint8Array",{emitterChain:this.chain,emitterAddress:new d(r.sender).toUniversalAddress(),sequence:BigInt(r.sequence),guardianSet:0,timestamp:Number(r.timestamp),consistencyLevel:r.consistency_level,nonce:r.nonce,signatures:[],payload:new Uint8Array(r.payload)})})}}m("Sui","WormholeCore",i);export{i as SuiWormholeCore};
