import{cP as ft,I as Hr,cQ as fr,cR as Te,aF as Zr,bE as nt,bF as Yr,bG as rr,at as ce,O as ge,s as oe,bV as Qr,bN as nr,bI as en,cS as tn,bJ as ht,L as rn,l as Re,aq as nn,ci as ir,cT as sn,N as sr,bS as hr,aw as an,U as on}from"./Bridge.js";import{g as tt,a as pt,i as Ve,S as Q,b as q,p as cn,c as un,d as it,u as De,e as pr,f as dn,h as qe,j as ln,k as fn}from"./sui-BZ3grhrf.js";import"./index-CFG8Auhr.js";import"./index.js";import"./pbkdf2-BTEK0Lcd.js";var hn=Object.defineProperty,pn=(e,t,r)=>t in e?hn(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,_=(e,t,r)=>pn(e,typeof t!="symbol"?t+"":t,r);class gr{constructor(t,r,n,i,s=!1){_(this,"transaction"),_(this,"network"),_(this,"chain"),_(this,"description"),_(this,"parallelizable"),this.transaction=t,this.network=r,this.chain=n,this.description=i,this.parallelizable=s}}class gn extends TypeError{constructor(t,r){let n;const{message:i,explanation:s,...o}=t,{path:c}=t,a=c.length===0?i:`At path: ${c.join(".")} -- ${i}`;super(s??a),s!=null&&(this.cause=a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>n??(n=[t,...r()])}}function yn(e){return G(e)&&typeof e[Symbol.iterator]=="function"}function G(e){return typeof e=="object"&&e!=null}function L(e){return typeof e=="symbol"?e.toString():typeof e=="string"?JSON.stringify(e):`${e}`}function mn(e){const{done:t,value:r}=e.next();return t?void 0:r}function wn(e,t,r,n){if(e===!0)return;e===!1?e={}:typeof e=="string"&&(e={message:e});const{path:i,branch:s}=t,{type:o}=r,{refinement:c,message:a=`Expected a value of type \`${o}\`${c?` with refinement \`${c}\``:""}, but received: \`${L(n)}\``}=e;return{value:n,type:o,refinement:c,key:i[i.length-1],path:i,branch:s,...e,message:a}}function*ar(e,t,r,n){yn(e)||(e=[e]);for(const i of e){const s=wn(i,t,r,n);s&&(yield s)}}function*kt(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:o=!1}=r,c={path:n,branch:i};if(s&&(e=t.coercer(e,c),o&&t.type!=="type"&&G(t.schema)&&G(e)&&!Array.isArray(e)))for(const u in e)t.schema[u]===void 0&&delete e[u];let a="valid";for(const u of t.validator(e,c))u.explanation=r.message,a="not_valid",yield[u,void 0];for(let[u,l,p]of t.entries(e,c)){const w=kt(l,p,{path:u===void 0?n:[...n,u],branch:u===void 0?i:[...i,l],coerce:s,mask:o,message:r.message});for(const g of w)g[0]?(a=g[0].refinement!=null?"not_refined":"not_valid",yield[g[0],void 0]):s&&(l=g[1],u===void 0?e=l:e instanceof Map?e.set(u,l):e instanceof Set?e.add(l):G(e)&&(l!==void 0||u in e)&&(e[u]=l))}if(a!=="not_valid")for(const u of t.refiner(e,c))u.explanation=r.message,a="not_refined",yield[u,void 0];a==="valid"&&(yield[void 0,e])}class te{constructor(t){const{type:r,schema:n,validator:i,refiner:s,coercer:o=a=>a,entries:c=function*(){}}=t;this.type=r,this.schema=n,this.entries=c,this.coercer=o,i?this.validator=(a,u)=>{const l=i(a,u);return ar(l,u,this,a)}:this.validator=()=>[],s?this.refiner=(a,u)=>{const l=s(a,u);return ar(l,u,this,a)}:this.refiner=()=>[]}assert(t,r){return gt(t,this,r)}create(t,r){return yr(t,this,r)}is(t){return F(t,this)}mask(t,r){return mr(t,this,r)}validate(t,r={}){return Ce(t,this,r)}}function gt(e,t,r){const n=Ce(e,t,{message:r});if(n[0])throw n[0]}function yr(e,t,r){const n=Ce(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function mr(e,t,r){const n=Ce(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function F(e,t){return!Ce(e,t)[0]}function Ce(e,t,r={}){const n=kt(e,t,r),i=mn(n);return i[0]?[new gn(i[0],function*(){for(const s of n)s[0]&&(yield s[0])}),void 0]:[void 0,i[1]]}function Oe(...e){const t=e[0].type==="type",r=e.map(i=>i.schema),n=Object.assign({},...r);return t?vn(n):y(n)}function W(e,t){return new te({type:e,schema:null,validator:t})}function yt(){return W("any",()=>!0)}function S(e){return new te({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${L(t)}`}})}function bn(){return W("bigint",e=>typeof e=="bigint")}function N(){return W("boolean",e=>typeof e=="boolean")}function ee(){return W("integer",e=>typeof e=="number"&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${L(e)}`)}function j(e){const t=L(e),r=typeof e;return new te({type:"literal",schema:r==="string"||r==="number"||r==="boolean"?e:null,validator(n){return n===e||`Expected the literal \`${t}\`, but received: ${L(n)}`}})}function wr(){return W("never",()=>!1)}function B(e){return new te({...e,validator:(t,r)=>t===null||e.validator(t,r),refiner:(t,r)=>t===null||e.refiner(t,r)})}function me(){return W("number",e=>typeof e=="number"&&!isNaN(e)||`Expected a number, but received: ${L(e)}`)}function y(e){const t=e?Object.keys(e):[],r=wr();return new te({type:"object",schema:e||null,*entries(n){if(e&&G(n)){const i=new Set(Object.keys(n));for(const s of t)i.delete(s),yield[s,n[s],e[s]];for(const s of i)yield[s,n[s],r]}},validator(n){return G(n)||`Expected an object, but received: ${L(n)}`},coercer(n){return G(n)?{...n}:n}})}function v(e){return new te({...e,validator:(t,r)=>t===void 0||e.validator(t,r),refiner:(t,r)=>t===void 0||e.refiner(t,r)})}function Y(e,t){return new te({type:"record",schema:null,*entries(r){if(G(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator(r){return G(r)||`Expected an object, but received: ${L(r)}`}})}function f(){return W("string",e=>typeof e=="string"||`Expected a string, but received: ${L(e)}`)}function br(e){const t=wr();return new te({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator(r){return Array.isArray(r)||`Expected an array, but received: ${L(r)}`}})}function vn(e){const t=Object.keys(e);return new te({type:"type",schema:e,*entries(r){if(G(r))for(const n of t)yield[n,r[n],e[n]]},validator(r){return G(r)||`Expected an object, but received: ${L(r)}`},coercer(r){return G(r)?{...r}:r}})}function C(e){const t=e.map(r=>r.type).join(" | ");return new te({type:"union",schema:null,coercer(r){for(const n of e){const[i,s]=n.validate(r,{coerce:!0});if(!i)return s}return r},validator(r,n){const i=[];for(const s of e){const[...o]=kt(r,s,n),[c]=o;if(c[0])for(const[a]of o)a&&i.push(a);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${L(r)}`,...i]}})}function vr(){return W("unknown",()=>!0)}const Tt=C([y({AddressOwner:f()}),y({ObjectOwner:f()}),y({Shared:y({initial_shared_version:B(f())})}),j("Immutable")]);W("SuiJsonValue",()=>!0);const jn=C([y({u32:f()}),y({u64:f()}),y({f64:f()})]);y({attributes:Y(f(),B(jn)),featureFlags:Y(f(),N()),maxSupportedProtocolVersion:f(),minSupportedProtocolVersion:f(),protocolVersion:f()});C([f(),j("package")]);const de=y({digest:f(),objectId:f(),version:C([me(),f(),bn()])});y({owner:Tt,reference:de});y({objectId:f(),sequenceNumber:f()});y({payment:S(de),owner:f(),price:f(),budget:f()});const kn=Oe(de,y({type:f(),owner:Tt,previousTransaction:f()})),Tn=Y(f(),yt()),Sn=Y(f(),vr()),En=y({type:f(),fields:Tn,hasPublicTransfer:N()}),In=y({disassembled:Sn}),xn=C([Oe(En,y({dataType:j("moveObject")})),Oe(In,y({dataType:j("package")}))]),On=y({type:f(),hasPublicTransfer:N(),version:f(),bcsBytes:f()}),An=y({id:f(),moduleMap:Y(f(),f())}),$n=C([Oe(On,y({dataType:j("moveObject")})),Oe(An,y({dataType:j("package")}))]);BigInt(1e9);const jr=y({code:f(),error:v(f()),object_id:v(f()),parent_object_id:v(f()),version:v(f()),digest:v(f())}),Bn=y({data:B(v(Y(f(),f()))),error:B(v(jr))}),Cn=C([Bn,v(Y(f(),f()))]),kr=y({objectId:f(),version:f(),digest:f(),type:B(v(f())),content:B(v(xn)),bcs:B(v($n)),owner:B(v(Tt)),previousTransaction:B(v(f())),storageRebate:B(v(f())),display:B(v(Cn))});y({showType:B(v(N())),showContent:B(v(N())),showBcs:B(v(N())),showOwner:B(v(N())),showPreviousTransaction:B(v(N())),showStorageRebate:B(v(N())),showDisplay:B(v(N()))});C([j("Exists"),j("notExists"),j("Deleted")]);S(kn);const Un=y({data:B(v(kr)),error:B(v(jr))});function _n(e){return e.data}function zn(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}function or(e){if("reference"in e)return e.reference;const t=_n(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:zn(e)}y({objectId:f(),atCheckpoint:v(me())});y({data:S(Un),nextCursor:v(B(f())),hasNextPage:N()});C([y({details:kr,status:j("VersionFound")}),y({details:f(),status:j("ObjectNotExists")}),y({details:de,status:j("ObjectDeleted")}),y({details:br([f(),me()]),status:j("VersionNotFound")}),y({details:y({asked_version:me(),latest_version:me(),object_id:f()}),status:j("VersionTooHigh")})]);const Pn=C([f(),y({Object:f()})]);S(Pn);const Mn=y({address:f(),name:f()}),Nn=C([j("Private"),j("Public"),j("Friend")]),St=y({abilities:S(f())}),Rn=y({constraints:St,isPhantom:N()}),Vn=y({TypeParameter:me()}),st=br([y({module:f(),package:f(),function:f()}),f()]);y({rank3Days:S(st),rank7Days:S(st),rank30Days:S(st)});function Tr(e){if(!e)return!1;if(typeof e=="string"||F(e,Vn)||Sr(e))return!0;if(typeof e!="object")return!1;const t=e;return!!(F(t.Reference,ve)||F(t.MutableReference,ve)||F(t.Vector,ve))}const ve=W("SuiMoveNormalizedType",Tr);function Sr(e){if(!e||typeof e!="object")return!1;const t=e;if(!t.Struct||typeof t.Struct!="object")return!1;const r=t.Struct;return!(typeof r.address!="string"||typeof r.module!="string"||typeof r.name!="string"||!Array.isArray(r.typeArguments)||!r.typeArguments.every(n=>Tr(n)))}W("SuiMoveNormalizedStructType",Sr);const Dn=y({visibility:Nn,isEntry:N(),typeParameters:S(St),parameters:S(ve),return:S(ve)}),Fn=y({name:f(),type:ve}),Wn=y({abilities:St,typeParameters:S(Rn),fields:S(Fn)}),Gn=y({fileFormatVersion:me(),address:f(),name:f(),friends:S(Mn),structs:Y(f(),Wn),exposedFunctions:Y(f(),Dn)});Y(f(),Gn);function mt(e){return typeof e=="object"&&"MutableReference"in e?e.MutableReference:void 0}function Er(e){return typeof e=="object"&&"Reference"in e?e.Reference:void 0}function Et(e){if(typeof e=="object"&&"Struct"in e)return e;const t=Er(e),r=mt(e);if(typeof t=="object"&&"Struct"in t)return t;if(typeof r=="object"&&"Struct"in r)return r}function Ln(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(t[s]!==255)throw new TypeError(i+" is ambiguous");t[s]=n}var o=e.length,c=e.charAt(0),a=Math.log(o)/Math.log(256),u=Math.log(256)/Math.log(o);function l(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var m=0,h=0,b=0,O=g.length;b!==O&&g[b]===0;)b++,m++;for(var U=(O-b)*u+1>>>0,I=new Uint8Array(U);b!==O;){for(var A=g[b],T=0,R=U-1;(A!==0||T<h)&&R!==-1;R--,T++)A+=256*I[R]>>>0,I[R]=A%o>>>0,A=A/o>>>0;if(A!==0)throw new Error("Non-zero carry");h=T,b++}for(var K=U-h;K!==U&&I[K]===0;)K++;for(var he=c.repeat(m);K<U;++K)he+=e.charAt(I[K]);return he}function p(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;for(var m=0,h=0,b=0;g[m]===c;)h++,m++;for(var O=(g.length-m)*a+1>>>0,U=new Uint8Array(O);g[m];){var I=t[g.charCodeAt(m)];if(I===255)return;for(var A=0,T=O-1;(I!==0||A<b)&&T!==-1;T--,A++)I+=o*U[T]>>>0,U[T]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");b=A,m++}for(var R=O-b;R!==O&&U[R]===0;)R++;for(var K=new Uint8Array(h+(O-R)),he=h;R!==O;)K[he++]=U[R++];return K}function w(g){var m=p(g);if(m)return m;throw new Error("Non-base"+o+" character")}return{encode:l,decodeUnsafe:p,decode:w}}var Kn=Ln;const Jn=Kn,qn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var Xn=Jn(qn);const Ir=an(Xn),Ue=e=>Ir.encode(e),It=e=>Ir.decode(e);function le(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))}const at=8192;function _e(e){if(e.length<at)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=at){const n=e.slice(r,r+at);t+=String.fromCharCode(...n)}return btoa(t)}function rt(e){var t;const r=e.startsWith("0x")?e.slice(2):e,n=((t=(r.length%2===0?r:`0${r}}`).match(/.{2}/g))==null?void 0:t.map(i=>parseInt(i,16)))??[];return Uint8Array.from(n)}function ze(e){return e.reduce((t,r)=>t+r.toString(16).padStart(2,"0"),"")}function xt(e){let t=[],r=0;if(e===0)return[0];for(;e>0;)t[r]=e&127,(e>>=7)&&(t[r]|=128),r+=1;return t}function Hn(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(i&127)<<r,!(i&128))break;r+=7}return{value:t,length:n}}class xr{constructor(t){this.bytePosition=0,this.dataView=new DataView(t.buffer)}shift(t){return this.bytePosition+=t,this}read8(){let t=this.dataView.getUint8(this.bytePosition);return this.shift(1),t}read16(){let t=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),t}read32(){let t=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),t}read64(){let t=this.read32(),r=this.read32().toString(16)+t.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){let t=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+t.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){let t=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+t.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(t){let r=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,r,t);return this.shift(t),n}readULEB(){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t),{value:n,length:i}=Hn(r);return this.shift(i),n}readVec(t){let r=this.readULEB(),n=[];for(let i=0;i<r;i++)n.push(t(this,i,r));return n}}function Zn(e,t){switch(t){case"base58":return Ue(e);case"base64":return _e(e);case"hex":return ze(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Yn(e,t){switch(t){case"base58":return It(e);case"base64":return le(e);case"hex":return rt(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Ot(e,t=["<",">"]){const[r,n]=t,i=[];let s="",o=0;for(let c=0;c<e.length;c++){const a=e[c];if(a===r&&o++,a===n&&o--,o===0&&a===","){i.push(s.trim()),s="";continue}s+=a}return i.push(s.trim()),i}class Or{constructor({size:t=1024,maxSize:r,allocateSize:n=1024}={}){this.bytePosition=0,this.size=t,this.maxSize=r||t,this.allocateSize=n,this.dataView=new DataView(new ArrayBuffer(t))}ensureSizeOrGrow(t){const r=this.bytePosition+t;if(r>this.size){const n=Math.min(this.maxSize,this.size+this.allocateSize);if(r>n)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`);this.size=n;const i=new ArrayBuffer(this.size);new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(i)}}shift(t){return this.bytePosition+=t,this}write8(t){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(t)),this.shift(1)}write16(t){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(t),!0),this.shift(2)}write32(t){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(t),!0),this.shift(4)}write64(t){return ot(BigInt(t),8).forEach(r=>this.write8(r)),this}write128(t){return ot(BigInt(t),16).forEach(r=>this.write8(r)),this}write256(t){return ot(BigInt(t),32).forEach(r=>this.write8(r)),this}writeULEB(t){return xt(t).forEach(r=>this.write8(r)),this}writeVec(t,r){return this.writeULEB(t.length),Array.from(t).forEach((n,i)=>r(this,n,i,t.length)),this}*[Symbol.iterator](){for(let t=0;t<this.bytePosition;t++)yield this.dataView.getUint8(t);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(t){return Zn(this.toBytes(),t)}}function ot(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e=e/BigInt(256),n+=1;return r}var Ar=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},X=(e,t,r)=>(Ar(e,t,"read from private field"),r?r.call(e):t.get(e)),Xe=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},He=(e,t,r,n)=>(Ar(e,t,"write to private field"),t.set(e,r),r),be,Se,Fe,ae;const $r=class{constructor(e){Xe(this,be,void 0),Xe(this,Se,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),He(this,be,e.write),He(this,Se,e.serialize??((t,r)=>{const n=new Or({size:this.serializedSize(t)??void 0,...r});return X(this,be).call(this,t,n),n.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),X(this,be).call(this,e,t)}serialize(e,t){return this.validate(e),new Qn(this,X(this,Se).call(this,e,t))}parse(e){const t=new xr(e);return this.read(t)}transform({name:e,input:t,output:r}){return new $r({name:e??this.name,read:n=>r(this.read(n)),write:(n,i)=>X(this,be).call(this,t(n),i),serializedSize:n=>this.serializedSize(t(n)),serialize:(n,i)=>X(this,Se).call(this,t(n),i),validate:n=>this.validate(t(n))})}};let H=$r;be=new WeakMap;Se=new WeakMap;const Br=Symbol.for("@mysten/serialized-bcs");function At(e){return!!e&&typeof e=="object"&&e[Br]===!0}class Qn{constructor(t,r){Xe(this,Fe,void 0),Xe(this,ae,void 0),He(this,Fe,t),He(this,ae,r)}get[Br](){return!0}toBytes(){return X(this,ae)}toHex(){return ze(X(this,ae))}toBase64(){return _e(X(this,ae))}toBase58(){return Ue(X(this,ae))}parse(){return X(this,Fe).parse(X(this,ae))}}Fe=new WeakMap;ae=new WeakMap;function Ze({size:e,...t}){return new H({...t,serializedSize:()=>e})}function ct({readMethod:e,writeMethod:t,...r}){return Ze({...r,read:n=>n[e](),write:(n,i)=>i[t](n),validate:n=>{var i;if(n<0||n>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,n)}})}function ut({readMethod:e,writeMethod:t,...r}){return Ze({...r,read:n=>n[e](),write:(n,i)=>i[t](BigInt(n)),validate:n=>{var i;const s=BigInt(n);if(s<0||s>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${s}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,s)}})}function ei({serialize:e,...t}){const r=new H({...t,serialize:e,write:(n,i)=>{for(const s of r.serialize(n).toBytes())i.write8(s)}});return r}function ti({toBytes:e,fromBytes:t,...r}){return new H({...r,read:n=>{const i=n.readULEB(),s=n.readBytes(i);return t(s)},write:(n,i)=>{const s=e(n);i.writeULEB(s.length);for(let o=0;o<s.length;o++)i.write8(s[o])},serialize:n=>{const i=e(n),s=xt(i.length),o=new Uint8Array(s.length+i.length);return o.set(s,0),o.set(i,s.length),o},validate:n=>{var i;if(typeof n!="string")throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);(i=r.validate)==null||i.call(r,n)}})}function ri(e){let t=null;function r(){return t||(t=e()),t}return new H({name:"lazy",read:n=>r().read(n),serializedSize:n=>r().serializedSize(n),write:(n,i)=>r().write(n,i),serialize:(n,i)=>r().serialize(n,i).toBytes()})}const d={u8(e){return ct({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...e})},u16(e){return ct({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...e})},u32(e){return ct({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e})},u64(e){return ut({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e})},u128(e){return ut({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e})},u256(e){return ut({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e})},bool(e){return Ze({name:"bool",size:1,read:t=>t.read8()===1,write:(t,r)=>r.write8(t?1:0),...e,validate:t=>{var r;if((r=e?.validate)==null||r.call(e,t),typeof t!="boolean")throw new TypeError(`Expected boolean, found ${typeof t}`)}})},uleb128(e){return ei({name:"uleb128",read:t=>t.readULEB(),serialize:t=>Uint8Array.from(xt(t)),...e})},bytes(e,t){return Ze({name:`bytes[${e}]`,size:e,read:r=>r.readBytes(e),write:(r,n)=>{for(let i=0;i<e;i++)n.write8(r[i]??0)},...t,validate:r=>{var n;if((n=t?.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}})},string(e){return ti({name:"string",toBytes:t=>new TextEncoder().encode(t),fromBytes:t=>new TextDecoder().decode(t),...e})},fixedArray(e,t,r){return new H({name:`${t.name}[${e}]`,read:n=>{const i=new Array(e);for(let s=0;s<e;s++)i[s]=t.read(n);return i},write:(n,i)=>{for(const s of n)t.write(s,i)},...r,validate:n=>{var i;if((i=r?.validate)==null||i.call(r,n),!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==e)throw new TypeError(`Expected array of length ${e}, found ${n.length}`)}})},option(e){return d.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:t=>t==null?{None:!0}:{Some:t},output:t=>"Some"in t?t.Some:null})},vector(e,t){return new H({name:`vector<${e.name}>`,read:r=>{const n=r.readULEB(),i=new Array(n);for(let s=0;s<n;s++)i[s]=e.read(r);return i},write:(r,n)=>{n.writeULEB(r.length);for(const i of r)e.write(i,n)},...t,validate:r=>{var n;if((n=t?.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`)}})},tuple(e,t){return new H({name:`(${e.map(r=>r.name).join(", ")})`,serializedSize:r=>{let n=0;for(let i=0;i<e.length;i++){const s=e[i].serializedSize(r[i]);if(s==null)return null;n+=s}return n},read:r=>{const n=[];for(const i of e)n.push(i.read(r));return n},write:(r,n)=>{for(let i=0;i<e.length;i++)e[i].write(r[i],n)},...t,validate:r=>{var n;if((n=t?.validate)==null||n.call(t,r),!Array.isArray(r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}})},struct(e,t,r){const n=Object.entries(t);return new H({name:e,serializedSize:i=>{let s=0;for(const[o,c]of n){const a=c.serializedSize(i[o]);if(a==null)return null;s+=a}return s},read:i=>{const s={};for(const[o,c]of n)s[o]=c.read(i);return s},write:(i,s)=>{for(const[o,c]of n)c.write(i[o],s)},...r,validate:i=>{var s;if((s=r?.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})},enum(e,t,r){const n=Object.entries(t);return new H({name:e,read:i=>{const s=i.readULEB(),[o,c]=n[s];return{[o]:c?.read(i)??!0}},write:(i,s)=>{const[o,c]=Object.entries(i)[0];for(let a=0;a<n.length;a++){const[u,l]=n[a];if(u===o){s.writeULEB(a),l?.write(c,s);return}}},...r,validate:i=>{var s;if((s=r?.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`);const o=Object.keys(i);if(o.length!==1)throw new TypeError(`Expected object with one key, found ${o.length}`);const[c]=o;if(!Object.hasOwn(t,c))throw new TypeError(`Invalid enum variant ${c}`)}})},map(e,t){return d.vector(d.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:r=>[...r.entries()],output:r=>{const n=new Map;for(const[i,s]of r)n.set(i,s);return n}})},generic(e,t){return(...r)=>t(...r).transform({name:`${t.name}<${r.map(n=>n.name).join(", ")}>`,input:n=>n,output:n=>n})},lazy(e){return ri(e)}},ni=32,Ee=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof Ee){this.schema=e.schema,this.types=new Map(e.types);return}if(this.schema=e,this.registerAddressType(Ee.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);e.withPrimitives!==!1&&ii(this)}tempKey(){return`bcs-struct-${++this.counter}`}ser(e,t,r){if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if(typeof e=="object"){const n=this.tempKey();return new Ee(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`)}de(e,t,r){if(typeof t=="string")if(r)t=Yn(t,r);else throw new Error("To pass a string to `bcs.de`, specify encoding");if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).decode(this,t,i)}if(typeof e=="object"){const n=new Ee(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=()=>!0){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(o,c,a,u){const l=s.reduce((p,w,g)=>Object.assign(p,{[w]:u[g]}),{});return this._encodeRaw.call(o,new Or(a),c,u,l)},decode(o,c,a){const u=s.reduce((l,p,w)=>Object.assign(l,{[p]:a[w]}),{});return this._decodeRaw.call(o,new xr(c),a,u)},_encodeRaw(o,c,a,u){if(n(c))return t.call(this,o,c,a,u);throw new Error(`Validation failed for type ${i}, data: ${c}`)},_decodeRaw(o,c,a){return r.call(this,o,c,a)}}),this}registerBcsType(e,t){return this.registerType(e,(r,n,i)=>{const s=i.map(o=>new H({name:String(o),write:(c,a)=>{const{name:u,params:l}=this.parseTypeName(o),p=this.getTypeInterface(u),w=l.reduce((g,m,h)=>Object.assign(g,{[m]:i[h]}),{});return p._encodeRaw.call(this,a,c,l,w)},read:()=>{throw new Error("Not implemented")}}));return t(...s).write(n,r),r},(r,n)=>{const i=n.map(s=>new H({name:String(s),write:(o,c)=>{throw new Error("Not implemented")},read:o=>{const{name:c,params:a}=this.parseTypeName(s),u=this.getTypeInterface(c),l=a.reduce((p,w,g)=>Object.assign(p,{[w]:n[g]}),{});return u._decodeRaw.call(this,o,a,l)}}));return t(...i).read(r)}),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,function(n,i){return le(i).reduce((s,o)=>s.write8(o),n)},function(n){return _e(n.readBytes(t))});case"hex":return this.registerType(e,function(n,i){return rt(i).reduce((s,o)=>s.write8(o),n)},function(n){return ze(n.readBytes(t))});default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,function(n,i,s,o){return n.writeVec(i,(c,a)=>{let u=s[0];if(!u)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:l,params:p}=this.parseTypeName(u);if(this.hasType(l))return this.getTypeInterface(l)._encodeRaw.call(this,c,a,p,o);if(!(l in o))throw new Error(`Unable to find a matching type definition for ${l} in vector; make sure you passed a generic`);let{name:w,params:g}=this.parseTypeName(o[l]);return this.getTypeInterface(w)._encodeRaw.call(this,c,a,g,o)})},function(n,i,s){return n.readVec(o=>{let c=i[0];if(!c)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:a,params:u}=this.parseTypeName(c);if(this.hasType(a))return this.getTypeInterface(a)._decodeRaw.call(this,o,u,s);if(!(a in s))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:l,params:p}=this.parseTypeName(s[a]);return this.getTypeInterface(l)._decodeRaw.call(this,o,p,s)})})}registerStructType(e,t){for(let o in t){let c=this.tempKey(),a=t[o];!Array.isArray(a)&&typeof a!="string"&&(t[o]=c,this.registerStructType(c,a))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(o,c,a,u){if(!c||c.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${c}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let l of n){if(!(l in c))throw new Error(`Struct ${i} requires field ${l}:${r[l]}`);const{name:p,params:w}=this.parseTypeName(r[l]);if(!s.includes(p))this.getTypeInterface(p)._encodeRaw.call(this,o,c[l],w,u);else{const g=s.indexOf(p);let{name:m,params:h}=this.parseTypeName(a[g]);if(this.hasType(m)){this.getTypeInterface(m)._encodeRaw.call(this,o,c[l],h,u);continue}if(!(m in u))throw new Error(`Unable to find a matching type definition for ${m} in ${i}; make sure you passed a generic`);let{name:b,params:O}=this.parseTypeName(u[m]);this.getTypeInterface(b)._encodeRaw.call(this,o,c[l],O,u)}}return o},function(o,c,a){if(c.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${c.length}`);let u={};for(let l of n){const{name:p,params:w}=this.parseTypeName(r[l]);if(!s.includes(p))u[l]=this.getTypeInterface(p)._decodeRaw.call(this,o,w,a);else{const g=s.indexOf(p);let{name:m,params:h}=this.parseTypeName(c[g]);if(this.hasType(m)){u[l]=this.getTypeInterface(m)._decodeRaw.call(this,o,h,a);continue}if(!(m in a))throw new Error(`Unable to find a matching type definition for ${m} in ${i}; make sure you passed a generic`);let{name:b,params:O}=this.parseTypeName(a[m]);u[l]=this.getTypeInterface(b)._decodeRaw.call(this,o,O,a)}}return u})}registerEnumType(e,t){for(let o in t){let c=this.tempKey(),a=t[o];a!==null&&!Array.isArray(a)&&typeof a!="string"&&(t[o]=c,this.registerStructType(c,a))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(o,c,a,u){if(!c)throw new Error(`Unable to write enum "${i}", missing data.
Received: "${c}"`);if(typeof c!="object")throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".
Received: "${JSON.stringify(c)}"`);let l=Object.keys(c)[0];if(l===void 0)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let p=n.indexOf(l);if(p===-1)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${l}"`);let w=n[p],g=r[w];if(o.write8(p),g===null)return o;let m=s.indexOf(g),h=m===-1?g:a[m];{let{name:b,params:O}=this.parseTypeName(h);return this.getTypeInterface(b)._encodeRaw.call(this,o,c[l],O,u)}},function(o,c,a){let u=o.readULEB(),l=n[u],p=r[l];if(u===-1)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${u}"`);if(p===null)return{[l]:!0};let w=s.indexOf(p),g=w===-1?p:c[w];{let{name:m,params:h}=this.parseTypeName(g);return{[l]:this.getTypeInterface(m)._decodeRaw.call(this,o,h,a)}}})}getTypeInterface(e){let t=this.types.get(e);if(typeof t=="string"){let r=[];for(;typeof t=="string";){if(r.includes(t))throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${t}`);r.push(t),t=this.types.get(t)}}if(t===void 0)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[c,...a]=e;return{name:c,params:a}}if(typeof e!="string")throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(n===-1&&i===-1)return{name:e,params:[]};if(n===-1||i===-1)throw new Error(`Unclosed generic in name '${e}'`);let s=e.slice(0,n),o=Ot(e.slice(n+1,e.length-i-1),this.schema.genericSeparators);return{name:s,params:o}}};let $=Ee;$.U8="u8";$.U16="u16";$.U32="u32";$.U64="u64";$.U128="u128";$.U256="u256";$.BOOL="bool";$.VECTOR="vector";$.ADDRESS="address";$.STRING="string";$.HEX="hex-string";$.BASE58="base58-string";$.BASE64="base64-string";function ii(e){e.registerType($.U8,function(t,r){return t.write8(r)},function(t){return t.read8()},t=>t<256),e.registerType($.U16,function(t,r){return t.write16(r)},function(t){return t.read16()},t=>t<65536),e.registerType($.U32,function(t,r){return t.write32(r)},function(t){return t.read32()},t=>t<=4294967296n),e.registerType($.U64,function(t,r){return t.write64(r)},function(t){return t.read64()}),e.registerType($.U128,function(t,r){return t.write128(r)},function(t){return t.read128()}),e.registerType($.U256,function(t,r){return t.write256(r)},function(t){return t.read256()}),e.registerType($.BOOL,function(t,r){return t.write8(r)},function(t){return t.read8().toString(10)==="1"}),e.registerType($.STRING,function(t,r){return t.writeVec(Array.from(r),(n,i)=>n.write8(i.charCodeAt(0)))},function(t){return t.readVec(r=>r.read8()).map(r=>String.fromCharCode(Number(r))).join("")},t=>!0),e.registerType($.HEX,function(t,r){return t.writeVec(Array.from(rt(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return ze(new Uint8Array(r))}),e.registerType($.BASE58,function(t,r){return t.writeVec(Array.from(It(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return Ue(new Uint8Array(r))}),e.registerType($.BASE64,function(t,r){return t.writeVec(Array.from(le(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return _e(new Uint8Array(r))})}function si(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:ni,addressEncoding:"hex"}}const $t=32;function ai(e){return ci(e)&&ui(e)===$t}function oi(e){return e.includes("::")?Cr(e):e}function Cr(e){const[t,r]=e.split("::"),n=e.slice(t.length+r.length+4),i=n.includes("<")?n.slice(0,n.indexOf("<")):n,s=n.includes("<")?Ot(n.slice(n.indexOf("<")+1,n.lastIndexOf(">"))).map(o=>oi(o.trim())):[];return{address:M(t),module:r,name:i,typeParams:s}}function M(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart($t*2,"0")}`}function je(e,t=!1){return M(e,t)}function ci(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}function ui(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}BigInt(1e9);const Bt="0x1",Ur="0x2",ye=je("0x6"),We=`${Ur}::sui::SUI`;je("0x5");const di="object",li="ID",fi="ascii",hi="String",pi="string",gi="String",yi="option",mi="Option",wi={address:Ur,module:di,name:li},bi={address:Bt,module:fi,name:hi},vi={address:Bt,module:pi,name:gi},ji={address:Bt,module:yi,name:mi},Pe=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function ki(e){var t;const r=(t=Et(e))==null?void 0:t.Struct;return r?.address==="0x2"&&r?.module==="tx_context"&&r?.name==="TxContext"}function dt(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const Ti=["Address","Bool","U8","U16","U32","U64","U128","U256"];function wt(e,t){if(typeof e=="string"&&Ti.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])dt("number",t);else if(e==="Bool")dt("boolean",t);else if(e==="Address"&&(dt("string",t),t&&!ai(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}else if(typeof e=="string")throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((t===void 0||typeof t=="string")&&e.Vector==="U8")return"string";if(t!==void 0&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=wt(e.Vector,t?t[0]:void 0);return r===void 0?void 0:`vector<${r}>`}if("Struct"in e){if(Pe(e.Struct,bi))return"string";if(Pe(e.Struct,vi))return"utf8string";if(Pe(e.Struct,wi))return"address";if(Pe(e.Struct,ji)){const r={Vector:e.Struct.typeArguments[0]};return wt(r,t)}}}const Si=/^vector<(.+)>$/,Ei=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ne{static parseFromStr(t,r=!1){if(t==="address")return{address:null};if(t==="bool")return{bool:null};if(t==="u8")return{u8:null};if(t==="u16")return{u16:null};if(t==="u32")return{u32:null};if(t==="u64")return{u64:null};if(t==="u128")return{u128:null};if(t==="u256")return{u256:null};if(t==="signer")return{signer:null};const n=t.match(Si);if(n)return{vector:ne.parseFromStr(n[1],r)};const i=t.match(Ei);if(i)return{struct:{address:r?M(i[1]):i[1],module:i[2],name:i[3],typeParams:i[5]===void 0?[]:ne.parseStructTypeArgs(i[5],r)}};throw new Error(`Encountered unexpected token when parsing type args for ${t}`)}static parseStructTypeArgs(t,r=!1){return Ot(t).map(n=>ne.parseFromStr(n,r))}static tagToString(t){if("bool"in t)return"bool";if("u8"in t)return"u8";if("u16"in t)return"u16";if("u32"in t)return"u32";if("u64"in t)return"u64";if("u128"in t)return"u128";if("u256"in t)return"u256";if("address"in t)return"address";if("signer"in t)return"signer";if("vector"in t)return`vector<${ne.tagToString(t.vector)}>`;if("struct"in t){const r=t.struct,n=r.typeParams.map(ne.tagToString).join(", ");return`${r.address}::${r.module}::${r.name}${n?`<${n}>`:""}`}throw new Error("Invalid TypeTag")}}const x=new $({...si(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function _r(e){return d.u64({name:"unsafe_u64",...e}).transform({input:t=>t,output:t=>Number(t)})}function Ii(e){return d.enum("Option",{None:null,Some:e})}function Ct(e){return e.transform({input:t=>({[t.kind]:t}),output:t=>{const r=Object.keys(t)[0];return{kind:r,...t[r]}}})}const Z=d.bytes($t).transform({input:e=>typeof e=="string"?rt(M(e)):e,output:e=>M(ze(e))}),Ut=d.vector(d.u8()).transform({name:"ObjectDigest",input:e=>It(e),output:e=>Ue(new Uint8Array(e))}),Ae=d.struct("SuiObjectRef",{objectId:Z,version:d.u64(),digest:Ut}),_t=d.struct("SharedObjectRef",{objectId:Z,initialSharedVersion:d.u64(),mutable:d.bool()}),Ye=d.enum("ObjectArg",{ImmOrOwned:Ae,Shared:_t,Receiving:Ae}),zt=d.enum("CallArg",{Pure:d.vector(d.u8()),Object:Ye,ObjVec:d.vector(Ye)}),ke=d.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:d.lazy(()=>ke),struct:d.lazy(()=>Dt),u16:null,u32:null,u256:null}),J=Ct(d.enum("Argument",{GasCoin:null,Input:d.struct("Input",{index:d.u16()}),Result:d.struct("Result",{index:d.u16()}),NestedResult:d.struct("NestedResult",{index:d.u16(),resultIndex:d.u16()})})),Pt=d.struct("ProgrammableMoveCall",{package:Z,module:d.string(),function:d.string(),type_arguments:d.vector(ke),arguments:d.vector(J)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map(s=>ne.parseFromStr(s,!0));return{package:M(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ne.tagToString)})}),Mt=Ct(d.enum("Transaction",{MoveCall:Pt,TransferObjects:d.struct("TransferObjects",{objects:d.vector(J),address:J}),SplitCoins:d.struct("SplitCoins",{coin:J,amounts:d.vector(J)}),MergeCoins:d.struct("MergeCoins",{destination:J,sources:d.vector(J)}),Publish:d.struct("Publish",{modules:d.vector(d.vector(d.u8())),dependencies:d.vector(Z)}),MakeMoveVec:d.struct("MakeMoveVec",{type:Ii(ke),objects:d.vector(J)}),Upgrade:d.struct("Upgrade",{modules:d.vector(d.vector(d.u8())),dependencies:d.vector(Z),packageId:Z,ticket:J})})),Nt=d.struct("ProgrammableTransaction",{inputs:d.vector(zt),transactions:d.vector(Mt)}),Rt=d.enum("TransactionKind",{ProgrammableTransaction:Nt,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Vt=d.enum("TransactionExpiration",{None:null,Epoch:_r()}),Dt=d.struct("StructTag",{address:Z,module:d.string(),name:d.string(),typeParams:d.vector(ke)}),Ft=d.struct("GasData",{payment:d.vector(Ae),owner:Z,price:d.u64(),budget:d.u64()}),Wt=d.struct("TransactionDataV1",{kind:Rt,sender:Z,gasData:Ft,expiration:Vt}),Gt=d.enum("TransactionData",{V1:Wt}),xi=d.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),Oi=d.enum("IntentVersion",{V0:null}),Ai=d.enum("AppId",{Sui:null}),$i=d.struct("Intent",{scope:xi,version:Oi,appId:Ai}),Bi=d.generic(["T"],e=>d.struct("IntentMessage<T>",{intent:$i,value:e})),Lt=d.enum("CompressedSignature",{ED25519:d.fixedArray(64,d.u8()),Secp256k1:d.fixedArray(64,d.u8()),Secp256r1:d.fixedArray(64,d.u8()),ZkLogin:d.vector(d.u8())}),Kt=d.enum("PublicKey",{ED25519:d.fixedArray(32,d.u8()),Secp256k1:d.fixedArray(33,d.u8()),Secp256r1:d.fixedArray(33,d.u8()),ZkLogin:d.vector(d.u8())}),Jt=d.struct("MultiSigPkMap",{pubKey:Kt,weight:d.u8()}),qt=d.struct("MultiSigPublicKey",{pk_map:d.vector(Jt),threshold:d.u16()}),zr=d.struct("MultiSig",{sigs:d.vector(Lt),bitmap:d.u16(),multisig_pk:qt}),Ci=d.vector(d.u8()).transform({input:e=>typeof e=="string"?le(e):e,output:e=>_e(new Uint8Array(e))}),Pr=d.struct("SenderSignedTransaction",{intentMessage:Bi(Gt),txSignatures:d.vector(Ci)}),Mr=d.vector(Pr,{name:"SenderSignedData"}),z={...d,U8:d.u8(),U16:d.u16(),U32:d.u32(),U64:d.u64(),U128:d.u128(),U256:d.u256(),ULEB128:d.uleb128(),Bool:d.bool(),String:d.string(),Address:Z,Argument:J,CallArg:zt,CompressedSignature:Lt,GasData:Ft,MultiSig:zr,MultiSigPkMap:Jt,MultiSigPublicKey:qt,ObjectArg:Ye,ObjectDigest:Ut,ProgrammableMoveCall:Pt,ProgrammableTransaction:Nt,PublicKey:Kt,SenderSignedData:Mr,SenderSignedTransaction:Pr,SharedObjectRef:_t,StructTag:Dt,SuiObjectRef:Ae,Transaction:Mt,TransactionData:Gt,TransactionDataV1:Wt,TransactionExpiration:Vt,TransactionKind:Rt,TypeTag:ke,ser:x.ser.bind(x),de:x.de.bind(x),getTypeInterface:x.getTypeInterface.bind(x),hasType:x.hasType.bind(x),parseTypeName:x.parseTypeName.bind(x),registerAddressType:x.registerAddressType.bind(x),registerAlias:x.registerAlias.bind(x),registerBcsType:x.registerBcsType.bind(x),registerEnumType:x.registerEnumType.bind(x),registerStructType:x.registerStructType.bind(x),registerType:x.registerType.bind(x),types:x.types};x.registerBcsType("utf8string",()=>d.string({name:"utf8string"}));x.registerBcsType("unsafe_u64",()=>_r());x.registerBcsType("enumKind",e=>Ct(e));[Z,J,zt,Lt,Ft,zr,Jt,qt,Ye,Ut,Pt,Nt,Kt,Mr,_t,Dt,Ae,Mt,Gt,Wt,Vt,Rt,ke].forEach(e=>{x.registerBcsType(e.name,()=>e)});const Ui=C([y({ImmOrOwned:de}),y({Shared:y({objectId:f(),initialSharedVersion:C([ee(),f()]),mutable:N()})}),y({Receiving:de})]),Qe=y({Pure:S(ee())}),bt=y({Object:Ui}),et=C([Qe,bt]);function _i(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:At(e)?e.toBytes():z.ser(t,e,{maxSize:1/0}).toBytes())}}const D={Pure:_i,ObjectRef({objectId:e,digest:t,version:r}){return{Object:{ImmOrOwned:{digest:t,version:r,objectId:M(e)}}}},SharedObjectRef({objectId:e,mutable:t,initialSharedVersion:r}){return{Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:M(e)}}}},ReceivingRef({objectId:e,digest:t,version:r}){return{Object:{Receiving:{digest:t,version:r,objectId:M(e)}}}}};function cr(e){return typeof e=="string"?M(e):"ImmOrOwned"in e.Object?M(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?M(e.Object.Receiving.objectId):M(e.Object.Shared.objectId)}function zi(e){return typeof e=="object"&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}function Pi(e){var t;return((t=zi(e))==null?void 0:t.mutable)??!1}function V(e,t){return yr(e,t)}const Mi=e=>C([y({None:C([j(!0),j(null)])}),y({Some:e})]),$e=C([y({kind:j("Input"),index:ee(),value:v(yt()),type:v(j("object"))}),y({kind:j("Input"),index:ee(),value:v(yt()),type:j("pure")})]),Ni=[$e,y({kind:j("GasCoin")}),y({kind:j("Result"),index:ee()}),y({kind:j("NestedResult"),index:ee(),resultIndex:ee()})],se=C([...Ni]),Nr=y({kind:j("MoveCall"),target:W("target",f().validator),typeArguments:S(f()),arguments:S(se)}),Rr=y({kind:j("TransferObjects"),objects:S(se),address:se}),Vr=y({kind:j("SplitCoins"),coin:se,amounts:S(se)}),Dr=y({kind:j("MergeCoins"),destination:se,sources:S(se)}),Fr=y({kind:j("MakeMoveVec"),type:v(Mi(Y(f(),vr()))),objects:S(se)}),Wr=y({kind:j("Publish"),modules:S(S(ee())),dependencies:S(f())}),Gr=y({kind:j("Upgrade"),modules:S(S(ee())),dependencies:S(f()),packageId:f(),ticket:se}),Ri=[Nr,Rr,Vr,Dr,Wr,Gr,Fr],Vi=C([...Ri]),pe={MoveCall(e){return V({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},Nr)},TransferObjects(e,t){return t.kind==="Input"&&t.type==="pure"&&typeof t.value!="object"&&(t.value=D.Pure(z.Address.serialize(t.value))),V({kind:"TransferObjects",objects:e,address:t},Rr)},SplitCoins(e,t){return t.forEach(r=>{r.kind==="Input"&&r.type==="pure"&&typeof r.value!="object"&&(r.value=D.Pure(z.U64.serialize(r.value)))}),V({kind:"SplitCoins",coin:e,amounts:t},Vr)},MergeCoins(e,t){return V({kind:"MergeCoins",destination:e,sources:t},Dr)},Publish({modules:e,dependencies:t}){return V({kind:"Publish",modules:e.map(r=>typeof r=="string"?Array.from(le(r)):r),dependencies:t.map(r=>je(r))},Wr)},Upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return V({kind:"Upgrade",modules:e.map(i=>typeof i=="string"?Array.from(le(i)):i),dependencies:t.map(i=>je(i)),packageId:r,ticket:n},Gr)},MakeMoveVec({type:e,objects:t}){return V({kind:"MakeMoveVec",type:e?{Some:ne.parseFromStr(e)}:{None:null},objects:t},Fr)}};function Di(e){function t(r,n){return e(r,n)}return t.u8=r=>e(z.U8.serialize(r)),t.u16=r=>e(z.U16.serialize(r)),t.u32=r=>e(z.U32.serialize(r)),t.u64=r=>e(z.U64.serialize(r)),t.u128=r=>e(z.U128.serialize(r)),t.u256=r=>e(z.U256.serialize(r)),t.bool=r=>e(z.Bool.serialize(r)),t.string=r=>e(z.String.serialize(r)),t.address=r=>e(z.Address.serialize(r)),t.id=t.address,t}function Fi(e,t){const r=Array.from(`${e}::`).map(i=>i.charCodeAt(0)),n=new Uint8Array(r.length+t.length);return n.set(r),n.set(t,r.length),on(n,{dkLen:32})}const Wi=v(B(C([y({Epoch:ee()}),y({None:C([j(!0),j(null)])})]))),ur=W("StringEncodedBigint",e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}}),Gi=y({budget:v(ur),price:v(ur),payment:v(S(de)),owner:v(f())}),Me=y({version:j(1),sender:v(f()),expiration:Wi,gasConfig:Gi,inputs:S($e),transactions:S(Vi)});function dr(e){return M(e).replace("0x","")}class ie{constructor(t){this.version=1,this.sender=t?.sender,this.expiration=t?.expiration,this.gasConfig=t?.gasConfig??{},this.inputs=t?.inputs??[],this.transactions=t?.transactions??[]}static fromKindBytes(t){const r=z.TransactionKind.parse(t),n="ProgrammableTransaction"in r?r.ProgrammableTransaction:null;if(!n)throw new Error("Unable to deserialize from bytes.");const i=V({version:1,gasConfig:{},inputs:n.inputs.map((s,o)=>V({kind:"Input",value:s,index:o,type:F(s,Qe)?"pure":"object"},$e)),transactions:n.transactions},Me);return ie.restore(i)}static fromBytes(t){var r;const n=z.TransactionData.parse(t),i=n?.V1,s="ProgrammableTransaction"in i.kind?(r=i?.kind)==null?void 0:r.ProgrammableTransaction:null;if(!i||!s)throw new Error("Unable to deserialize from bytes.");const o=V({version:1,sender:i.sender,expiration:i.expiration,gasConfig:i.gasData,inputs:s.inputs.map((c,a)=>V({kind:"Input",value:c,index:a,type:F(c,Qe)?"pure":"object"},$e)),transactions:s.transactions},Me);return ie.restore(o)}static restore(t){gt(t,Me);const r=new ie;return Object.assign(r,t),r}static getDigestFromBytes(t){const r=Fi("TransactionData",t);return Ue(r)}build({maxSizeBytes:t=1/0,overrides:r,onlyTransactionKind:n}={}){const i=this.inputs.map(l=>(gt(l.value,et),l.value)),s={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(n)return z.TransactionKind.serialize(s,{maxSize:t}).toBytes();const o=r?.expiration??this.expiration,c=r?.sender??this.sender,a={...this.gasConfig,...r?.gasConfig};if(!c)throw new Error("Missing transaction sender");if(!a.budget)throw new Error("Missing gas budget");if(!a.payment)throw new Error("Missing gas payment");if(!a.price)throw new Error("Missing gas price");const u={sender:dr(c),expiration:o||{None:!0},gasData:{payment:a.payment,owner:dr(this.gasConfig.owner??c),price:BigInt(a.price),budget:BigInt(a.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return z.TransactionData.serialize({V1:u},{maxSize:t}).toBytes()}getDigest(){const t=this.build({onlyTransactionKind:!1});return ie.getDigestFromBytes(t)}snapshot(){return V(this,Me)}}var Xt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},E=(e,t,r)=>(Xt(e,t,"read from private field"),r?r.call(e):t.get(e)),re=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ne=(e,t,r,n)=>(Xt(e,t,"write to private field"),t.set(e,r),r),P=(e,t,r)=>(Xt(e,t,"access private method"),r),k,Ie,Ge,xe,Le,fe,we,Ht,Lr,Zt,Kr,Yt,Jr,Qt,qr,Ke,vt;const Li={maxPureArgumentSize:16*1024,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:128*1024};function Ki(e){const t={kind:"Result",index:e},r=[],n=i=>r[i]??(r[i]={kind:"NestedResult",index:e,resultIndex:i});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,s){if(s in i)return Reflect.get(i,s);if(s===Symbol.iterator)return function*(){let c=0;for(;;)yield n(c),c++};if(typeof s=="symbol")return;const o=parseInt(s,10);if(!(Number.isNaN(o)||o<0))return n(o)}})}function Ji(e){const t=Et(e);return t?t.Struct.address==="0x2"&&t.Struct.module==="transfer"&&t.Struct.name==="Receiving":!1}function Be(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const qi=Symbol.for("@mysten/transaction"),lt={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},Xi=1000n,Hi=50,Zi=(e,t)=>Array.from({length:Math.ceil(e.length/t)},(r,n)=>e.slice(n*t,n*t+t)),jt=class{constructor(e){re(this,Ie),re(this,xe),re(this,fe),re(this,Ht),re(this,Zt),re(this,Yt),re(this,Qt),re(this,Ke),re(this,k,void 0),Ne(this,k,new ie(e?e.blockData:void 0))}static fromKind(e){const t=new jt;return Ne(t,k,ie.fromKindBytes(typeof e=="string"?le(e):e)),t}static from(e){const t=new jt;return typeof e!="string"||!e.startsWith("{")?Ne(t,k,ie.fromBytes(typeof e=="string"?le(e):e)):Ne(t,k,ie.restore(JSON.parse(e))),t}setSender(e){E(this,k).sender=e}setSenderIfNotSet(e){E(this,k).sender||(E(this,k).sender=e)}setExpiration(e){E(this,k).expiration=e}setGasPrice(e){E(this,k).gasConfig.price=String(e)}setGasBudget(e){E(this,k).gasConfig.budget=String(e)}setGasOwner(e){E(this,k).gasConfig.owner=e}setGasPayment(e){E(this,k).gasConfig.payment=e.map(t=>mr(t,de))}get blockData(){return E(this,k).snapshot()}get[qi](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Di((e,t)=>At(e)?P(this,Ie,Ge).call(this,"pure",{Pure:Array.from(e.toBytes())}):P(this,Ie,Ge).call(this,"pure",e instanceof Uint8Array?D.Pure(e):t?D.Pure(e,t):e))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if(typeof e=="object"&&"kind"in e)return e;const t=cr(e),r=E(this,k).inputs.find(n=>n.type==="object"&&t===cr(n.value));return r&&F(r.value,bt)&&"Shared"in r.value.Object&&F(e,bt)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??P(this,Ie,Ge).call(this,"object",typeof e=="string"?M(e):e)}objectRef(...e){return this.object(D.ObjectRef(...e))}receivingRef(...e){return this.object(D.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(D.SharedObjectRef(...e))}add(e){const t=E(this,k).transactions.push(e);return Ki(t-1)}splitCoins(e,t){return this.add(pe.SplitCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="number"||typeof r=="bigint"||typeof r=="string"?this.pure.u64(r):P(this,xe,Le).call(this,r))))}mergeCoins(e,t){return this.add(pe.MergeCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="string"?this.object(r):r)))}publish({modules:e,dependencies:t}){return this.add(pe.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return this.add(pe.Upgrade({modules:e,dependencies:t,packageId:r,ticket:typeof n=="string"?this.object(n):n}))}moveCall({arguments:e,typeArguments:t,target:r}){return this.add(pe.MoveCall({arguments:e?.map(n=>P(this,xe,Le).call(this,n)),typeArguments:t,target:r}))}transferObjects(e,t){return this.add(pe.TransferObjects(e.map(r=>typeof r=="string"?this.object(r):r),typeof t=="string"?this.pure.address(t):P(this,xe,Le).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(pe.MakeMoveVec({type:e,objects:t.map(r=>typeof r=="string"?this.object(r):r)}))}serialize(){return JSON.stringify(E(this,k).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(e={}){return await P(this,Ke,vt).call(this,e),E(this,k).build({maxSizeBytes:P(this,fe,we).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await P(this,Ke,vt).call(this,e),E(this,k).getDigest()}};let ue=jt;k=new WeakMap;Ie=new WeakSet;Ge=function(e,t){const r=E(this,k).inputs.length,n=V({kind:"Input",value:typeof t=="bigint"?String(t):t,index:r,type:e},$e);return E(this,k).inputs.push(n),n};xe=new WeakSet;Le=function(e){return At(e)?this.pure(e):e};fe=new WeakSet;we=function(e,{protocolConfig:t,limits:r}){if(r&&typeof r[e]=="number")return r[e];if(!t)return Li[e];const n=t?.attributes[lt[e]];if(!n)throw new Error(`Missing expected protocol config: "${lt[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${lt[e]}"`);return Number(i)};Ht=new WeakSet;Lr=function(e){const t=P(this,fe,we).call(this,"maxPureArgumentSize",e);E(this,k).inputs.forEach((r,n)=>{if(F(r.value,Qe)&&r.value.Pure.length>t)throw new Error(`Input at index ${n} is too large, max pure input size is ${t} bytes, got ${r.value.Pure.length} bytes`)})};Zt=new WeakSet;Kr=async function(e){if(E(this,k).gasConfig.payment){const n=P(this,fe,we).call(this,"maxGasObjects",e);if(E(this,k).gasConfig.payment.length>n)throw new Error(`Payment objects exceed maximum amount: ${n}`)}if(e.onlyTransactionKind||E(this,k).gasConfig.payment)return;const t=E(this,k).gasConfig.owner??E(this,k).sender,r=(await Be(e).getCoins({owner:t,coinType:We})).data.filter(n=>!E(this,k).inputs.find(i=>F(i.value,et)&&"Object"in i.value&&"ImmOrOwned"in i.value.Object?n.coinObjectId===i.value.Object.ImmOrOwned.objectId:!1)).slice(0,P(this,fe,we).call(this,"maxGasObjects",e)-1).map(n=>({objectId:n.coinObjectId,digest:n.digest,version:n.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)};Yt=new WeakSet;Jr=async function(e){e.onlyTransactionKind||E(this,k).gasConfig.price||this.setGasPrice(await Be(e).getReferenceGasPrice())};Qt=new WeakSet;qr=async function(e){const{inputs:t,transactions:r}=E(this,k),n=[],i=[];if(t.forEach(s=>{if(s.type==="object"&&typeof s.value=="string"){i.push({id:M(s.value),input:s});return}}),r.forEach(s=>{if(s.kind==="MoveCall"&&s.arguments.some(o=>o.kind==="Input"&&!F(t[o.index].value,et))&&n.push(s),s.kind==="SplitCoins"&&s.amounts.forEach(o=>{if(o.kind==="Input"){const c=t[o.index];typeof c.value!="object"&&(c.value=D.Pure(z.U64.serialize(c.value)))}}),s.kind==="TransferObjects"&&s.address.kind==="Input"){const o=t[s.address.index];typeof o.value!="object"&&(o.value=D.Pure(z.Address.serialize(o.value)))}}),n.length&&await Promise.all(n.map(async s=>{const[o,c,a]=s.target.split("::"),u=await Be(e).getNormalizedMoveFunction({package:je(o),module:c,function:a}),l=u.parameters.length>0&&ki(u.parameters.at(-1))?u.parameters.slice(0,u.parameters.length-1):u.parameters;if(l.length!==s.arguments.length)throw new Error("Incorrect number of arguments.");l.forEach((p,w)=>{const g=s.arguments[w];if(g.kind!=="Input")return;const m=t[g.index];if(F(m.value,et))return;const h=m.value,b=wt(p,h);if(b){m.value=D.Pure(h,b);return}if(Et(p)!=null||typeof p=="object"&&"TypeParameter"in p){if(typeof h!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(h,null,2)}`);i.push({id:h,input:m,normalizedType:p});return}throw new Error(`Unknown call arg type ${JSON.stringify(p,null,2)} for value ${JSON.stringify(h,null,2)}`)})})),i.length){const s=[...new Set(i.map(({id:l})=>l))],o=Zi(s,Hi),c=(await Promise.all(o.map(l=>Be(e).multiGetObjects({ids:l,options:{showOwner:!0}})))).flat();let a=new Map(s.map((l,p)=>[l,c[p]]));const u=Array.from(a).filter(([l,p])=>p.error).map(([l,p])=>l);if(u.length)throw new Error(`The following input objects are invalid: ${u.join(", ")}`);i.forEach(({id:l,input:p,normalizedType:w})=>{var g;const m=a.get(l),h=(g=m.data)==null?void 0:g.owner,b=h&&typeof h=="object"&&"Shared"in h?h.Shared.initial_shared_version:void 0;if(b){const O=w!=null&&mt(w)==null&&Er(w)==null,U=Pi(p.value)||O||w!=null&&mt(w)!=null;p.value=D.SharedObjectRef({objectId:l,initialSharedVersion:b,mutable:U})}else w&&Ji(w)?p.value=D.ReceivingRef(or(m)):p.value=D.ObjectRef(or(m))})}};Ke=new WeakSet;vt=async function(e){if(!e.onlyTransactionKind&&!E(this,k).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([P(this,Yt,Jr).call(this,e),P(this,Qt,qr).call(this,e)]),!e.onlyTransactionKind&&(await P(this,Zt,Kr).call(this,e),!E(this,k).gasConfig.budget)){const t=await Be(e).dryRunTransactionBlock({transactionBlock:E(this,k).build({maxSizeBytes:P(this,fe,we).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(P(this,fe,we).call(this,"maxTxGas",e)),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=Xi*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}P(this,Ht,Lr).call(this,e)};const lr=async(e,t,r)=>{var n,i,s;if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const o=await tt(e,t);if(!o)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const c=(i=(n=o.token_registry.fields)==null?void 0:n.id)==null?void 0:i.id;if(!c)throw new Error("Unable to fetch token registry object ID");const a=Hr((s=o.token_registry)==null?void 0:s.type);if(!a)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:c,name:{type:`${a}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},Je=async(e,t,r,n)=>{var i,s,o,c;const a=await tt(e,t);if(!a)throw new Error("Unable to fetch object fields from token bridge state");const u=(s=(i=a.token_registry)==null?void 0:i.fields)==null?void 0:s.coin_types,l=(c=(o=u?.fields)==null?void 0:o.id)==null?void 0:c.id;if(!l)throw new Error("Unable to fetch coin types");const p=fr(u?.type);if(!p)throw new Error("Unable to get key type");const w=await e.getDynamicFieldObject({parentId:l,name:{type:p,value:{addr:[...r],chain:n}}});if(w.error){if(w.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${w.error}`)}const g=pt(w);if(!g)return null;if(!Ve(g))throw new Error("What?");return"value"in g?Te(g.value):null};class er{constructor(t,r,n,i){_(this,"network"),_(this,"chain"),_(this,"provider"),_(this,"contracts"),_(this,"coreBridgeObjectId"),_(this,"tokenBridgeObjectId"),_(this,"chainId"),this.network=t,this.chain=r,this.provider=n,this.contracts=i,this.chainId=Zr.get(t,r);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=o}static async fromRpc(t,r){const[n,i]=await Q.chainFromRpc(t),s=r[i];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new er(n,i,t,s.contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{return!1}}async getOriginalAsset(t){let r=t.getCoinType();if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const n=await lr(this.provider,this.tokenBridgeObjectId,r),i=pt(n);if(!i)throw nt(r);if(!Ve(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!q(s))throw new Error("Expected fields to be a MoveStruct");const o=Te(s.type);if(r=Te(r),o.includes(`wrapped_asset::WrappedAsset<${r}>`)){const c=s.fields.info;if(!q(c))throw new Error("Expected fields to be a MoveStruct");const a=c.fields.token_address;if(!q(a))throw new Error("Expected fields to be a MoveStruct");if(!Ve(a.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in a.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const u=a.fields.value;if(!q(u))throw new Error("Expected fields to be a MoveStruct");const l=new Uint8Array(u.fields.data);return{chain:Yr(Number(c.fields.token_chain)),address:new rr(l)}}throw nt(r)}async getTokenUniversalAddress(t){let r=t.getCoinType();if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const n=await lr(this.provider,this.tokenBridgeObjectId,r),i=pt(n);if(!i)throw new Error(`Token of type ${r} has not been registered with the token bridge. Has it been attested?`);if(!Ve(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!q(s))throw new Error("Expected fields to be a MoveStruct");const o=Te(s.type);if(r=Te(r),o.includes(`native_asset::NativeAsset<${r}>`)){const c=s.fields.token_address;if(!q(c))throw new Error("Expected fields to be a MoveStruct");if(!("value"in c.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const a=c.fields.value;if(!q(a))throw new Error("Expected fields to be a MoveStruct");const u=new Uint8Array(a.fields.data);return new rr(u)}throw new Error(`Token of type ${r} is not a native asset`)}async getTokenNativeAddress(t,r){const n=await Je(this.provider,this.tokenBridgeObjectId,r.toUint8Array(),ce(t));if(!n)throw new Error(`Token ${r.toString()} not found in token registry`);return new ge(n)}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(oe(t.address))throw new Error("Token Address required, 'native' literal not supported");const r=await Je(this.provider,this.tokenBridgeObjectId,t.address.toUniversalAddress().toUint8Array(),ce(t.chain));if(!r)throw nt(Qr(t));return nr(this.chain,r)}async isTransferCompleted(t){var r,n,i,s,o,c,a,u;const l=await tt(this.provider,this.tokenBridgeObjectId);if(!l)throw new Error("Unable to fetch object fields from token bridge state");const p=(n=(r=l.consumed_vaas)==null?void 0:r.fields)==null?void 0:n.hashes,w=fr((s=(i=p?.fields)==null?void 0:i.items)==null?void 0:s.type);if(!w)throw new Error("Unable to get key type");const g=(u=(a=(c=(o=p?.fields)==null?void 0:o.items)==null?void 0:c.fields)==null?void 0:a.id)==null?void 0:u.id;if(!g)throw new Error("Unable to fetch consumed VAAs table");const m=await this.provider.getDynamicFieldObject({parentId:g,name:{type:w,value:{data:[...en(t.hash)]}}});if(!m.error)return!0;if(m.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${m.error}`)}async*createAttestation(t){const r=0n,n=0n,i=t.toString(),s=await this.provider.getCoinMetadata({coinType:i});if(s===null||s.id===null)throw new Error(`Coin metadata ID for type ${i} not found`);const[o,c]=await this.getPackageIds(),a=new ue,[u]=a.splitCoins(a.gas,[a.pure(r)]),[l]=a.moveCall({target:`${c}::attest_token::attest_token`,arguments:[a.object(this.tokenBridgeObjectId),a.object(s.id),a.pure(n)],typeArguments:[i]});a.moveCall({target:`${o}::publish_message::publish_message`,arguments:[a.object(this.coreBridgeObjectId),u,l,a.object(ye)]}),yield this.createUnsignedTx(a,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(t,r){const[n,i]=await this.getPackageIds(),s=r.toString(),o=Math.min(t.payload.decimals,8),c=await this.getCoinBuildOutput(n,i,o),a=await cn(c,s);yield this.createUnsignedTx(a,"Sui.TokenBridge.PrepareCreateWrapped");let u="",l="",p="",w="",g="",m=!1;for(;!m;){await new Promise(A=>setTimeout(A,500));const I=await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3});for(const A of I.data)if("objectChanges"in A){for(const T of A.objectChanges)un(T)&&T.packageId!==void 0?u=T.packageId:it(T)&&T.objectType.includes("WrappedAssetSetup")?(l=T.objectId,g=T.objectType.split(", ")[1].replace(">","")):it(T)&&T.objectType.includes("UpgradeCap")?p=T.objectId:it(T)&&T.objectType.includes("CoinMetadata")&&(w=T.objectId);if(u!==""&&l!==""&&p!==""&&w!==""){m=!0;break}else u="",l="",p="",w=""}}const h=tn(u),b=new ue,[O]=b.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[b.object(this.coreBridgeObjectId),b.pure(De(ht(t))),b.object(ye)]}),[U]=b.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[b.object(this.tokenBridgeObjectId),O]});b.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[b.object(this.tokenBridgeObjectId),b.object(w),b.object(l),b.object(p),U],typeArguments:[h,g]}),yield this.createUnsignedTx(b,"Sui.TokenBridge.SubmitAttestation")}async*transfer(t,r,n,i,s){const o=0n,c=0n,a=t.toString(),u=(oe(n)?We:n).toString(),l=await Q.getCoins(this.provider,t,u),[p,...w]=l.filter(I=>pr(I.coinType,u));if(p===void 0)throw new Error(`Coins array doesn't contain any coins of type ${u}`);const[g,m]=await this.getPackageIds(),h=new ue,[b]=(()=>{if(u===We)return h.splitCoins(h.gas,[h.pure(i)]);{const I=h.object(p.coinObjectId);return w.length&&h.mergeCoins(I,w.map(A=>h.object(A.coinObjectId))),h.splitCoins(I,[h.pure(i)])}})(),[O]=h.splitCoins(h.gas,[h.pure(o)]),[U]=h.moveCall({target:`${m}::state::verified_asset`,arguments:[h.object(this.tokenBridgeObjectId)],typeArguments:[u]});if(s){if(!a)throw new Error("senderAddress is required for transfer with payload");let I=!1;const A=await(async()=>{const he=await dn(this.provider,g,a);if(he!==null)return h.object(he);{const[Xr]=h.moveCall({target:`${g}::emitter::new`,arguments:[h.object(this.coreBridgeObjectId)]});return I=!0,Xr}})(),[T,R]=h.moveCall({target:`${m}::transfer_tokens_with_payload::prepare_transfer`,arguments:[A,U,b,h.pure(ce(r.chain)),h.pure(r.address.toUint8Array()),h.pure([...s]),h.pure(0)],typeArguments:[u]});h.moveCall({target:`${m}::coin_utils::return_nonzero`,arguments:[R],typeArguments:[u]});const[K]=h.moveCall({target:`${m}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[h.object(this.tokenBridgeObjectId),T],typeArguments:[u]});h.moveCall({target:`${g}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),O,K,h.object(ye)]}),I&&h.transferObjects([A],h.pure(a)),yield this.createUnsignedTx(h,"Sui.TokenBridge.TransferWithPayload")}else{const[I,A]=h.moveCall({target:`${m}::transfer_tokens::prepare_transfer`,arguments:[U,b,h.pure(ce(r.chain)),h.pure(De(r.address.toUint8Array())),h.pure(c),h.pure(0)],typeArguments:[u]});h.moveCall({target:`${m}::coin_utils::return_nonzero`,arguments:[A],typeArguments:[u]});const[T]=h.moveCall({target:`${m}::transfer_tokens::transfer_tokens`,arguments:[h.object(this.tokenBridgeObjectId),I],typeArguments:[u]});h.moveCall({target:`${g}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),O,T,h.object(ye)]}),yield this.createUnsignedTx(h,"Sui.TokenBridge.Transfer")}}async*redeem(t,r,n=!0){const i=await Je(this.provider,this.tokenBridgeObjectId,r.payload.token.address.toUint8Array(),ce(r.payload.token.chain));if(!i)throw new Error("Unable to fetch token coinType");const[s,o]=await this.getPackageIds(),c=new ue,[a]=c.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[c.object(this.coreBridgeObjectId),c.pure(De(ht(r))),c.object(ye)]}),[u]=c.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[c.object(this.tokenBridgeObjectId),a]}),[l]=c.moveCall({target:`${o}::complete_transfer::authorize_transfer`,arguments:[c.object(this.tokenBridgeObjectId),u],typeArguments:[i]}),[p]=c.moveCall({target:`${o}::complete_transfer::redeem_relayer_payout`,arguments:[l],typeArguments:[i]});c.moveCall({target:`${o}::coin_utils::return_nonzero`,arguments:[p],typeArguments:[i]}),yield this.createUnsignedTx(c,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return nr(this.chain,We)}async getPackageIds(){return Promise.all([qe(this.provider,this.coreBridgeObjectId),qe(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(t,r,n){var i;if(n>8)throw new Error("Decimals is capped at 8");const s=(i=await ln(this.provider,this.tokenBridgeObjectId))==null?void 0:i.replace("0x","");if(!s)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const o="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+s+"00020106010000000001090b0031"+n.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[rn.encode(Re.decode(o))],dependencies:["0x1","0x2",r,t].map(c=>je(c))}}createUnsignedTx(t,r,n=!1){return new gr(t,this.network,this.chain,r,n)}}class tr{constructor(t,r,n,i){_(this,"network"),_(this,"chain"),_(this,"connection"),_(this,"contracts"),_(this,"tokenBridgeRelayerObjectId"),_(this,"coreBridgeObjectId"),_(this,"tokenBridgeObjectId"),_(this,"fields"),this.network=t,this.chain=r,this.connection=n,this.contracts=i;const{tokenBridge:s,tokenBridgeRelayer:o,coreBridge:c}=i;if(!s||!o||!c)throw new Error(`Some object IDs for ${r} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=o,this.tokenBridgeObjectId=s,this.coreBridgeObjectId=c}static async fromRpc(t,r){const[n,i]=await Q.chainFromRpc(t),s=r[i];if(s.network!==n)throw new Error(`Network mismatch for chain ${i}: ${s.network} != ${n}`);return new tr(n,i,t,s.contracts)}async*transfer(t,r,n,i,s){const o=new ge(oe(n)?Q.nativeTokenId(this.network,this.chain).address:n).getCoinType(),{coreBridge:c,tokenBridge:a}=await this.getPackageIds(),u=new ue,l=BigInt(0),[p]=u.splitCoins(u.gas,[u.pure(l)]),[w]=await(async()=>{if(oe(n))return u.splitCoins(u.gas,[u.pure(i)]);{const O=await Q.getCoins(this.connection,t,o),[U,...I]=O.filter(T=>T.coinType===o);if(U===void 0)throw new Error(`Coins array doesn't contain any coins of type ${o}`);const A=u.object(U.coinObjectId);return I.length&&u.mergeCoins(A,I.map(T=>u.object(T.coinObjectId))),u.splitCoins(A,[u.pure(i)])}})(),[g]=u.moveCall({target:`${a}::state::verified_asset`,arguments:[u.object(this.tokenBridgeObjectId)],typeArguments:[o]}),m=await this.getPackageId(),[h]=u.moveCall({target:`${m}::transfer::transfer_tokens_with_relay`,arguments:[u.object(this.tokenBridgeRelayerObjectId),w,g,u.pure.u64(s??0n),u.pure.u16(ce(r.chain)),u.pure.address(Re.encode(r.address.toUint8Array(),!0)),u.pure.u32(123)],typeArguments:[o]}),[b]=u.moveCall({target:`${a}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[u.object(this.tokenBridgeObjectId),h],typeArguments:[o]});u.moveCall({target:`${c}::publish_message::publish_message`,arguments:[u.object(this.coreBridgeObjectId),p,b,u.object(ye)]}),yield this.createUnsignedTx(u,"AutomaticTokenBridge.transfer")}async*redeem(t,r){const{coreBridge:n,tokenBridge:i}=await this.getPackageIds(),{address:s,chain:o}=r.payload.token,c=await Je(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),ce(o));if(!c)throw new Error("Unable to fetch token coinType");const a=new ue,[u]=a.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[a.object(this.coreBridgeObjectId),a.pure(De(ht(r))),a.object(ye)]}),[l]=a.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[a.object(this.tokenBridgeObjectId),u]}),[p]=a.moveCall({target:`${i}::complete_transfer_with_payload::authorize_transfer`,arguments:[a.object(this.tokenBridgeObjectId),l],typeArguments:[c]}),w=await this.getPackageId();a.moveCall({target:`${w}::redeem::complete_transfer`,arguments:[a.object(this.tokenBridgeRelayerObjectId),p],typeArguments:[c]}),yield this.createUnsignedTx(a,"AutomaticTokenBridge.redeem")}async getRelayerFee(t,r){const n=oe(r)?Q.nativeTokenId(this.network,this.chain):r,i=await this.getTokenInfo(n.toString());if(i===null)throw new Error("Unsupported token for relay");const s=await this.getFields(),o=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(nn.encode("relayer_fees"))}});if(!o.data||!o.data.content)throw o.error?new Error("Failed to get relayer fees: "+JSON.stringify(o.error)):new Error("Unable to compute relayer fee");const{content:c}=o.data;if(!q(c)||!fn(c.fields.id))throw new Error("Unable to compute relayer fee");const a=await this.connection.getDynamicFieldObject({parentId:c.fields.id.id,name:{type:"u16",value:ce(t)}});if(!a.data||!a.data.content)throw a.error?new Error("Failed to get relayer fees: "+JSON.stringify(o.error)):new Error("Unable to compute relayer fee");const{content:u}=a.data;if(!q(u))throw new Error("Unable to compute relayer fee");const l=await Q.getDecimals(this.chain,this.connection,r.toString()),p=i.swap_rate,w=s.relayer_fee_precision,g=s.swap_rate_precision,m=u.fields.value;return 10n**BigInt(l)*BigInt(m)*BigInt(g)/(BigInt(p)*BigInt(w))}async maxSwapAmount(t){var r,n;const i=(oe(t)?Q.nativeTokenId(this.network,this.chain):t).toString(),s=await this.connection.getCoinMetadata({coinType:i});if(!s)throw new Error("metadata is null");const o=await this.getPackageId(),c=new ue;c.moveCall({target:`${o}::redeem::calculate_max_swap_amount_in`,arguments:[c.object(this.tokenBridgeRelayerObjectId),c.pure(s.decimals)],typeArguments:[i]});const a=await this.connection.devInspectTransactionBlock({transactionBlock:c,sender:Re.encode(new Uint8Array(32))});if(!a.results||a.results.length==0||!((r=a.results[0])!=null&&r.returnValues)||((n=a.results[0])==null?void 0:n.returnValues.length)!==1)throw Error("swap rate not set");return ir.decode(new Uint8Array(a.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(t,r){var n,i;const s=(oe(t)?Q.nativeTokenId(this.network,this.chain):t).toString(),o=await this.connection.getCoinMetadata({coinType:s});if(!o)throw new Error("metadata is null");const c=await this.getPackageId(),a=new ue;a.moveCall({target:`${c}::redeem::calculate_native_swap_amount_out`,arguments:[a.object(this.tokenBridgeRelayerObjectId),a.pure(r),a.pure(o.decimals)],typeArguments:[s]});const u=await this.connection.devInspectTransactionBlock({transactionBlock:a,sender:Re.encode(new Uint8Array(32))});if(!u.results||u.results.length==0||!((n=u.results[0])!=null&&n.returnValues)||((i=u.results[0])==null?void 0:i.returnValues.length)!==1)throw Error("swap rate not set");return ir.decode(new Uint8Array(u.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const t=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:t})).data.map(r=>{const{address:n,module:i,name:s}=Cr(r.objectType).typeParams[0];return new ge([n,i,s].join(sn))})}async isRegisteredToken(t){const r=new ge(oe(t)?Q.nativeTokenId(this.network,this.chain).address:t).unwrap();try{return await this.getTokenInfo(r)!==null}catch(n){console.error(n)}return!1}async getTokenInfo(t){var r;const n=await this.getFields(),i=new ge(n.registered_tokens.type).getPackageId(),s=n.registered_tokens.fields.id.id,o=new ge(t),c=pr(sr,o.unwrap())?sr:o.getCoinType();try{const a=await this.connection.getDynamicFieldObject({parentId:s,name:{type:`${i}::registered_tokens::Key<${c}>`,value:{dummy_field:!1}}});if(a.error)throw new Error("Failed to get token info: "+JSON.stringify(a.error));if(!a.data||!a.data.content)throw new Error("Failed to get token info: "+JSON.stringify(a));const{content:u}=a.data;return q(u)&&q(u.fields.value)?u.fields.value.fields:null}catch(a){if(a?.code===-32e3&&(r=a.message)!=null&&r.includes("RPC Error"))return console.error(a),null;throw a}}async getFields(){if(!this.fields){const t=await tt(this.connection,this.tokenBridgeRelayerObjectId);if(t===null)throw new Error("Failed to get fields from token bridge relayer state");this.fields=t}return this.fields}async getPackageId(){const t=await this.getFields();return new ge(t.registered_tokens.type).getPackageId()}async getPackageIds(){const[t,r]=await Promise.all([qe(this.connection,this.coreBridgeObjectId),qe(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:t,tokenBridge:r}}createUnsignedTx(t,r,n=!1){return new gr(t,this.network,this.chain,r,n)}}hr("Sui","TokenBridge",er);hr("Sui","AutomaticTokenBridge",tr);export{tr as SuiAutomaticTokenBridge,er as SuiTokenBridge,Je as getTokenCoinType,lr as getTokenFromTokenRegistry};
