import{bR as D,p as a,bT as H,aF as M,a as v,E as C,bU as p,bV as d,bW as j,at as S,bM as l,bF as V,b6 as I,bJ as L,bX as _,bY as J,bO as X,bP as Y,bS as K,_ as Z,s as B,l as y,an as T}from"./Bridge.js";import{EvmTokenBridge as tt}from"./index-CNq6iUaG.js";import"./index.js";var et=Object.defineProperty,nt=(u,e,t)=>e in u?et(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t,h=(u,e,t)=>nt(u,typeof e!="symbol"?e+"":e,t);const F=new D(["function start((bytes32,address,address,address,address,address,uint256,uint256,uint256,uint256)) returns (address,uint16,uint64)","function receiveMessageAndSwap(bytes)"]),rt=new D(["function quoteExactInputSingle((address,address,uint256,uint24,uint160)) public view returns (uint256,uint160,uint32,uint256)"]),at="https://gfx.relayers.xlabs.xyz/api/v1/swap/quote";class ot{static async quoteRelayer(e,t,r){var n;if(B(t)||B(r))throw new Error("how did you get here tho?");const o=y.encode(t.toUniversalAddress().toUint8Array(),!1),c=y.encode(r.toUniversalAddress().toUint8Array(),!1),s={targetChain:S(e),sourceToken:o,targetToken:c};try{const i=await T.post(at,s);return BigInt(i.data.fee)}catch(i){throw T.isAxiosError(i)?new Error(`Error getting relayer fee: ${(n=i.response)==null?void 0:n.statusText}`):i}}}const k=100,x={ETH:[a.tokenId("Arbitrum","native"),a.tokenId("Base","native"),a.tokenId("Ethereum","native"),a.tokenId("Optimism","native")],WETH:[a.tokenId("Arbitrum","0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"),a.tokenId("Avalanche","0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB"),a.tokenId("Base","0x4200000000000000000000000000000000000006"),a.tokenId("Bsc","0x2170Ed0880ac9A755fd29B2688956BD959F933F8"),a.tokenId("Ethereum","0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"),a.tokenId("Optimism","0x4200000000000000000000000000000000000006"),a.tokenId("Polygon","0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619")],wstETH:[a.tokenId("Arbitrum","0x5979D7b546E38E414F7E9822514be443A4800529"),a.tokenId("Base","0xc1CBa3fCea344f92D9239c08C0568f6F2F0ee452"),a.tokenId("Ethereum","0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0"),a.tokenId("Optimism","0x1F32b1c2345538c0c6f582fCB022739c4A194Ebb"),a.tokenId("Polygon","0x03b54A6e9a984069379fae1a4fC4dBAE93B3bCCD")],USDT:[a.tokenId("Arbitrum","0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9"),a.tokenId("Avalanche","0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7"),a.tokenId("Base","0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2"),a.tokenId("Bsc","0x55d398326f99059fF775485246999027B3197955"),a.tokenId("Ethereum","0xdAC17F958D2ee523a2206206994597C13D831ec7"),a.tokenId("Optimism","0x94b008aA00579c1307B0EF2c499aD98a8ce58e58"),a.tokenId("Polygon","0xc2132D05D31c914a87C6611C10748AEb04B58e8F"),a.tokenId("Celo","0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e")]};class b{constructor(e,t,r,n){if(h(this,"network"),h(this,"chain"),h(this,"provider"),h(this,"contracts"),h(this,"chainId"),h(this,"core"),h(this,"tokenBridge"),this.network=e,this.chain=t,this.provider=r,this.contracts=n,!n.portico)throw new Error("Unsupported chain, no contract addresses for: "+t);this.core=new H(e,t,r,n),this.tokenBridge=new tt(e,t,r,n),this.chainId=M.get(e,t)}static async fromRpc(e,t){const[r,n]=await v.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error(`Network mismatch: ${o.network} != ${r}`);return new b(r,n,e,o.contracts)}async*transfer(e,t,r,n,o,c,s){const{minAmountStart:i,minAmountFinish:f}=s.swapAmounts;if(i===0n)throw new Error("Invalid min swap amount");if(f===0n)throw new Error("Invalid min swap amount");const m=new C(e).toString(),[w,E]=p(this.network,this.chain,r),[P,U]=p(this.network,t.chain,o),g=d(E),$=d(await this.getTransferrableToken(g)),N=d(t),O=d(U),q=new Date().valueOf()%2**4,R=j.serializeFlagSet({flags:{shouldWrapNative:w,shouldUnwrapNative:P},recipientChain:S(t.chain),bridgeNonce:q,feeTierStart:k,feeTierFinish:k,padding:new Uint8Array(19)}),W=F.encodeFunctionData("start",[[R,g.toLowerCase(),$,O.toLowerCase(),N,c,n.toString(),i.toString(),f.toString(),s.relayerFee.toString()]]),Q=this.getTokenGroup(E.address.toString()),A=this.getPorticoAddress(Q);w||(yield*this.approve(g,m,n,A));const z=await this.core.getMessageFee(),G={to:A,data:W,value:z+(w?n:0n)};yield this.createUnsignedTransaction(l(G,m),"PorticoBridge.Transfer")}async*redeem(e,t){const r=V(t.payload.payload.flagSet.recipientChain),n=t.payload.payload.finalTokenAddress.toNative(r).toString(),o=this.getTokenGroup(n),c=this.getPorticoAddress(o),s=await new I(c,F.fragments,this.provider).getFunction("receiveMessageAndSwap").populateTransaction(L(t)),i=new C(e).toString();yield this.createUnsignedTransaction(l(s,i),"PorticoBridge.Redeem")}async isTransferCompleted(e){return await this.tokenBridge.tokenBridge.isTransferCompleted(_(e.hash))}async quoteSwap(e,t,r,n){const[,o]=p(this.network,this.chain,e),[,c]=p(this.network,this.chain,t),s=d(o),i=d(c);if(J(s,i))return n;const f=this.getQuoterAddress(r);return(await new I(f,rt.fragments,this.provider).getFunction("quoteExactInputSingle").staticCall([s,i,n,k,0]))[0]}async quoteRelay(e,t){return await ot.quoteRelayer(this.chain,e,t)}async getTransferrableToken(e){const t=a.tokenId(this.chain,e),[,r]=p(this.network,this.chain,t);if(this.chain==="Ethereum")return r;const n=Object.values(x).find(s=>s.find(i=>i.chain===this.chain&&d(i)===d(r)));if(!n)throw new Error(`No token group found for ${e} on ${this.chain}`);const o=n.find(s=>s.chain==="Ethereum");if(!o)throw new Error(`No Ethereum origin token found for ${e} on ${this.chain}`);const c=await this.tokenBridge.getWrappedAsset(o);return a.tokenId(this.chain,c.toString())}supportedTokens(){const e=[];for(const[t,r]of Object.entries(x))for(const n of r)n.chain===this.chain&&e.push({group:t,token:n});return e}getTokenGroup(e){const t=this.supportedTokens().find(r=>d(r.token)===e);if(!t)throw new Error("Token not found");return t.group}async*approve(e,t,r,n){const o=v.getTokenImplementation(this.provider,e);if(await o.allowance(t,n)<r){const c=await o.approve.populateTransaction(n,r);yield this.createUnsignedTransaction(l(c,t),"PorticoBridge.Approve")}}createUnsignedTransaction(e,t){return new X(Y(e,this.chainId),this.network,this.chain,t,!1)}getPorticoAddress(e){const t=this.contracts.portico;return e==="USDT"&&t.porticoPancakeSwap||t.porticoUniswap}getQuoterAddress(e){const t=this.contracts.portico;return e==="USDT"&&t.pancakeSwapQuoterV2||t.uniswapQuoterV2}}K(Z,"PorticoBridge",b);export{b as EvmPorticoBridge};
