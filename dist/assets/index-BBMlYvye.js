import"./index-1U60lnae.js";import{C as p,G as T}from"./cosmwasm-DY1PMAJO.js";import{T as o,h as g,F as C}from"./unsignedTransaction-CzttHBqx.js";import{s as f,L as c,at as A,bN as b,ap as a,bF as W,bG as x,bJ as y,bS as $,ax as E}from"./Bridge.js";import"./index.js";import"./pbkdf2-BTEK0Lcd.js";import"./keccak-OTA2ssQD.js";import"./index-Dtqiiobd.js";var q=Object.defineProperty,P=(h,t,e)=>t in h?q(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e,d=(h,t,e)=>P(h,typeof t!="symbol"?t+"":t,e);class k{constructor(t,e,r,n){d(this,"network"),d(this,"chain"),d(this,"rpc"),d(this,"contracts"),d(this,"tokenBridge"),d(this,"translator"),this.network=t,this.chain=e,this.rpc=r,this.contracts=n;const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);if(this.tokenBridge=s,this.translator=this.contracts.translator,this.translator!==void 0&&this.translator==="")throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(t,e){const[r,n]=await p.chainFromRpc(t),s=e[n];if(s.network!==r)throw new Error(`Network mismatch: ${s.network} != ${r}`);return new k(r,n,t,e[n].contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{}return!1}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(t.chain===this.chain)throw new Error(`Expected foreign chain, got ${t.chain}`);if(f(t.address))throw new Error("Native asset cannot be a wrapped asset");const e=c.encode(t.address.toUniversalAddress().toUint8Array()),{address:r}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:A(t.chain),address:e}});return b(this.chain,r)}async getOriginalAsset(t){let e=new a(t);e.denomType==="factory"&&(e=T.factoryToCw20(e));const r=await this.rpc.queryContractSmart(e.toString(),{wrapped_asset_info:{}}),n=W(r.asset_chain),s=c.decode(r.asset_address);return{chain:n,address:new x(new Uint8Array(s))}}async getTokenUniversalAddress(t){return new a(t).toUniversalAddress()}async getTokenNativeAddress(t,e){return new a(e).toNative()}async isTransferCompleted(t){const e=c.encode(y(t));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:e}})).is_redeemed}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const r=new a(t).toString(),n=new a(e).toString(),s=0,m=f(t)?{native_token:{denom:p.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:r}};yield this.createUnsignedTx({msgs:[o(n,this.tokenBridge,{create_asset_meta:{asset_info:m,nonce:s}})],fee:g(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(t,e){if(!e)throw new Error("Payer required to submit attestation");const r=new a(e).toString();yield this.createUnsignedTx({msgs:[o(r,this.tokenBridge,{submit_vaa:{data:y(t)}})],fee:g(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(t,e,r,n,s){const m=Math.round(Math.random()*1e5),B="0",S=A(e.chain),U=c.encode(e.address.toUniversalAddress().toUint8Array()),N=p.getNativeDenom(this.network,this.chain),u=f(r);let i=u?N:r.toString();i.startsWith("factory")&&(i=T.factoryToCw20(new a(i)).toString());const l=new a(t).toString(),v=w=>{const _={asset:{amount:n.toString(),info:w},recipient_chain:S,recipient:U,fee:B,nonce:m};return s?{initiate_transfer_with_payload:{..._,payload:c.encode(s)}}:{initiate_transfer:_}};if(u){const w=[o(l,this.tokenBridge,{deposit_tokens:{}},[{amount:n.toString(),denom:i}]),o(l,this.tokenBridge,v({native_token:{denom:i}}))];yield this.createUnsignedTx({msgs:w,fee:g(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const w=[o(l,i,{increase_allowance:{spender:this.tokenBridge,amount:n.toString(),expires:{never:{}}}}),o(l,this.tokenBridge,v({token:{contract_addr:i}}),[{amount:n.toString(),denom:i}])];yield this.createUnsignedTx({msgs:w,fee:g(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}async*redeem(t,e,r=!0){const n=c.encode(y(e)),s=new a(t).toString(),m=this.translator&&new a(this.translator).toUniversalAddress().equals(e.payload.to.address)?o(s,this.translator,{complete_transfer_and_convert:{vaa:n}}):o(s,this.tokenBridge,{submit_vaa:{data:n}});yield this.createUnsignedTx({msgs:[m],fee:g(this.network,this.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}async parseTransactionDetails(t){throw new Error("Not implemented")}async getWrappedNative(){return b(this.chain,p.getNativeDenom(this.network,this.chain))}createUnsignedTx(t,e,r=!1){return new C(t,this.network,this.chain,e,r)}}$(E,"TokenBridge",k);export{k as CosmwasmTokenBridge};
