import{A as O,S as A,a as Q}from"./index-BaZ9ZXQ8.js";import{dj as X,aq as S,bS as Y,aV as Z,at as L,d7 as E,aU as m,dk as W,db as F,bF as ee,ci as b,bG as te,s as V,bN as G,dc as k,d9 as l,dd as x,dg as N,bJ as q,d6 as H,dl as se,dm as J,dn as oe}from"./Bridge.js";import{A as ne}from"./algorand-DGFW1DOS.js";import"./index.js";var re=Object.defineProperty,ae=(v,t,e)=>t in v?re(v,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):v[t]=e,c=(v,t,e)=>ae(v,typeof t!="symbol"?t+"":t,e);const K=X.fromSignature("portal_transfer(byte[])byte[]"),C=class f{constructor(t,e,n,o){if(c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreBridge"),c(this,"coreAppId"),c(this,"coreAppAddress"),c(this,"tokenBridgeAppId"),c(this,"tokenBridgeAddress"),this.network=t,this.chain=e,this.connection=n,this.contracts=o,this.chainId=L(e),!o.coreBridge)throw new Error(`Core contract address for chain ${e} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=E(r),this.coreBridge=new O(t,e,n,o),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${e} not found`);const s=BigInt(o.tokenBridge);this.tokenBridgeAppId=s,this.tokenBridgeAddress=E(s)}static async fromRpc(t,e){const[n,o]=await ne.chainFromRpc(t),r=e[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} != ${n}`);return new f(n,o,t,r.contracts)}async isWrappedAsset(t){const e=new m(t).toInt();if(e===0)return!1;const n=await this.connection.getAssetByID(e).do(),o=W.from_obj_for_encoding(n).params.creator,r=await this.connection.accountInformation(o).exclude("all").do(),s=F.from_obj_for_encoding(r);return s?.authAddr===this.tokenBridgeAddress}async getOriginalAsset(t){const e=new m(t).toInt(),n=await this.connection.getAssetByID(e).do(),o=W.from_obj_for_encoding(n),r=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,o.params.creator);if(r.length<94)throw new Error("Invalid local state data");const s=r.slice(92,94),a=ee(b.decode(s)),p=new te(r.slice(60,92));return{chain:a,address:p}}async getTokenUniversalAddress(t){return new m(t).toUniversalAddress()}async getTokenNativeAddress(t,e){return new m(e).toNative()}async getWrappedAsset(t){if(V(t.address))throw new Error("native asset cannot be a wrapped asset");const e=A.forWrappedAsset(this.tokenBridgeAppId,t),n=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,e.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return G(this.chain,b.decode(n.slice(0,8)).toString())}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedNative(){return G(this.chain,"0")}async isTransferCompleted(t){const e=A.forMessageId(this.tokenBridgeAppId,{sequence:t.sequence,chain:t.emitterChain,emitter:t.emitterAddress});try{return await A.checkBitsSet(this.connection,this.tokenBridgeAppId,e.address(),t.sequence)}catch{}return!1}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const n=new m(e).toString(),o=new m(t).toInt(),r=[],s=await this.connection.getTransactionParams().do(),a=A.forEmitter(this.coreAppId,new m(this.tokenBridgeAddress).toUint8Array()),{accounts:[p],txs:g}=await O.maybeCreateStorageTx(this.connection,n,this.coreAppId,a,s);r.push(...g);let B="",i;if(o!==0){const I=await this.connection.getAssetByID(o).do(),U=W.from_obj_for_encoding(I),_=await this.connection.accountInformation(U.params.creator).do();if(i=F.from_obj_for_encoding(_),i.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const T=A.forNativeAsset(this.tokenBridgeAppId,BigInt(o)),y=await O.maybeCreateStorageTx(this.connection,n,this.tokenBridgeAppId,T);B=y.accounts[0],r.push(...y.txs);const u=k({from:n,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.noop],suggestedParams:s});r.push({tx:u});const h=await this.coreBridge.getMessageFee();if(h>BigInt(0)){const I=N({from:n,suggestedParams:s,to:this.tokenBridgeAddress,amount:h});r.push({tx:I})}let j=[p,B,this.coreAppAddress];i&&j.push(i.address);let d=k({appArgs:[f.attestToken,b.toBytes(o,8)],accounts:j,appIndex:l(this.tokenBridgeAppId),foreignApps:[l(this.coreAppId)],foreignAssets:[o],from:n,onComplete:x.NoOpOC,suggestedParams:s});h>BigInt(0)?d.fee*=3:d.fee*=2,r.push({tx:d});for(const I of r)yield this.createUnsignedTx(I,"TokenBridge.createAttestation",!0)}async*submitAttestation(t,e,n){if(!e)throw new Error("Sender required to submit attestation");n||(n=await this.connection.getTransactionParams().do());const o=e.toString(),r=A.forWrappedAsset(this.tokenBridgeAppId,t.payload.token).address(),s=[],a=[],p=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,r);p.length>8&&a.push(new m(p.slice(0,8)).toInt()),s.push({tx:N({from:o,to:r,amount:1e5,suggestedParams:n})});let g=new Uint8Array(1);g[0]=1,s.push({tx:k({appArgs:[f.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),g=new Uint8Array(1),g[0]=2,s.push({tx:k({appArgs:[f.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s.push({tx:k({accounts:[],appArgs:[f.receiveAttest,q(t)],appIndex:l(this.tokenBridgeAppId),foreignAssets:a,from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s[s.length-1].tx.fee=s[s.length-1].tx.fee*2;for(const B of s)yield this.createUnsignedTx(B,"TokenBridge.submitAttestation",!0)}async*transfer(t,e,n,o,r){const s=t.toString(),a=V(n)?0:new m(n).toInt(),p=o,g=L(e.chain),B=e.address.toUniversalAddress().toUint8Array(),i=await this.connection.getTransactionParams().do(),T=BigInt(0),y=A.fromData({appId:this.coreAppId,appAddress:H(this.coreAppAddress).publicKey,idx:BigInt(0),address:H(this.tokenBridgeAddress).publicKey}),u=[],{accounts:[h],txs:j}=await O.maybeCreateStorageTx(this.connection,s,this.coreAppId,y,i);u.push(...j);let d="",I,U=!1;if(a!==0){const w=await this.connection.getAssetByID(a).do();d=W.from_obj_for_encoding(w).params.creator;const P=await this.connection.accountInformation(d).do();I=F.from_obj_for_encoding(P),U=I.authAddr===this.tokenBridgeAddress.toString()}const _=await this.coreBridge.getMessageFee();if(_>0&&u.push({tx:N({from:s,to:this.tokenBridgeAddress,amount:_,suggestedParams:i})}),!U){const w=A.forNativeAsset(this.tokenBridgeAppId,BigInt(a)),{accounts:[P],txs:R}=await O.maybeCreateStorageTx(this.connection,s,this.tokenBridgeAppId,w,i);d=P,R.push(...R)}if(a!==0&&!await f.isOptedInToAsset(this.connection,d,a)){const w=N({from:s,to:d,amount:1e5,suggestedParams:i});let P=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.optIn,se(a,8)],foreignAssets:[a],accounts:[d],suggestedParams:i});P.fee*=2,u.unshift({tx:w},{tx:P})}const z=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[f.noop],suggestedParams:i});u.push({tx:z});let $=[];if(a===0){const w=N({from:s,to:d,amount:p,suggestedParams:i});u.push({tx:w}),$=[h,d,d]}else{const w=J({from:s,to:d,amount:p,assetIndex:a,suggestedParams:i});u.push({tx:w}),$=I!=null&&I.address?[h,d,I.address]:[h,d]}const D=[f.sendTransfer,b.toBytes(a,8),b.toBytes(p,8),B,b.toBytes(g,8),b.toBytes(T,8)];r&&D.push(r);const M=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:D,foreignApps:[l(this.coreAppId)],foreignAssets:[a],accounts:$,suggestedParams:i});M.fee*=2,u.push({tx:M});for(const w of u)yield this.createUnsignedTx(w,"TokenBridge.transfer",!0)}async*redeem(t,e,n=!0,o){o||(o=await this.connection.getTransactionParams().do());const r=new m(t).toString(),{accounts:s,txs:a}=await O.submitVAAHeader(this.connection,this.coreAppId,this.tokenBridgeAppId,e,r);let p,g="",B=[],i=0;if(e.payload.token.chain!==this.chain){p=A.forWrappedAsset(this.tokenBridgeAppId,e.payload.token),g=p.address();const h=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,g);i=new m(h.slice(0,8)).toInt()}else{const h=new m(e.payload.token.address).toBigInt();p=A.forNativeAsset(this.tokenBridgeAppId,h),g=p.address(),i=l(h)}s.push(g);let T=0,y="";if(e.payloadName==="TransferWithPayload"?(T=new m(e.payload.to.address).toInt(),y=E(T)):y=new m(e.payload.to.address.toUint8Array()).toString(),s.push(y),i!==0&&(B.push(i),!await f.isOptedInToAsset(this.connection,y,i))){if(r!=y)throw new Error("Cannot ASA optin for somebody else (asset "+i.toString()+")");a.unshift({tx:J({amount:0,assetIndex:i,from:r,suggestedParams:o,to:r})})}const u={accounts:s,appArgs:[f.completeTransfer,q(e)],appIndex:l(this.tokenBridgeAppId),foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o};a.push({tx:k(u)}),a[a.length-1].tx.fee=a[a.length-1].tx.fee*(e.payloadName==="Transfer"&&e.payload.fee!==void 0&&e.payload.fee===0n?2:3),e.payloadName==="TransferWithPayload"&&(a[a.length-1].tx.appForeignApps=[T],a.push({tx:k({appArgs:[K.getSelector(),K.args[0].type.encode(q(e))],appIndex:T,foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o})}));for(const h of a)yield this.createUnsignedTx(h,"TokenBridge.redeem",!0)}static async isOptedInToAsset(t,e,n){var o;try{const r=await t.accountAssetInformation(e,n).do();return(((o=oe.from_obj_for_encoding(r).assetHolding)==null?void 0:o.amount)??0)>0}catch{}return!1}createUnsignedTx(t,e,n=!0){return new Q(t,this.network,this.chain,e,n)}};c(C,"sendTransfer",S.encode("sendTransfer")),c(C,"attestToken",S.encode("attestToken")),c(C,"noop",S.encode("nop")),c(C,"optIn",S.encode("optin")),c(C,"completeTransfer",S.encode("completeTransfer")),c(C,"receiveAttest",S.encode("receiveAttest"));let ie=C;Y(Z,"TokenBridge",ie);export{ie as AlgorandTokenBridge,K as TransferMethodSelector};
