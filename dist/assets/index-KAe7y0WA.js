import{at as h,bG as d,cI as m,l as w,bS as p}from"./Bridge.js";import{A as l}from"./aptos-Bbj6gw3L.js";import"./index.js";var g=Object.defineProperty,u=(a,e,t)=>e in a?g(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,s=(a,e,t)=>u(a,typeof e!="symbol"?e+"":e,t);class i{constructor(e,t,n,o){s(this,"network"),s(this,"chain"),s(this,"connection"),s(this,"contracts"),s(this,"chainId"),s(this,"coreBridge"),this.network=e,this.chain=t,this.connection=n,this.contracts=o,this.chainId=h(t);const r=o.coreBridge;if(!r)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=r}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[n,o]=await l.chainFromRpc(e),r=t[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} !== ${n}`);return new i(n,o,e,r.contracts)}async*publishMessage(e,t){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(t=>({chain:t.emitterChain,emitter:t.emitterAddress,sequence:t.sequence}))}async parseMessages(e){const t=await this.connection.getTransactionByHash(e);if(t.type!=="user_transaction")throw new Error(`${e} is not a user_transaction`);const n=t.events.filter(o=>o.type.endsWith("WormholeMessage"));if(!n||n.length===0)throw new Error(`WormholeMessage not found for ${e}`);return n.map(o=>{const r=o.data,c=new d(BigInt(r.sender).toString(16).padStart(64,"0"));return m("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:c,sequence:BigInt(r.sequence),timestamp:Number(r.timestamp),consistencyLevel:r.consistency_level,nonce:Number(r.nonce),signatures:[],payload:w.decode(r.payload)})})}}p("Aptos","WormholeCore",i);export{i as AptosWormholeCore};
