import{e as f,K as B,h as T,T as P,i as E,j as y,k as K,l as S,C as _}from"./Bridge.js";var M=Object.defineProperty,$=(o,e,t)=>e in o?M(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,m=(o,e,t)=>$(o,typeof e!="symbol"?e+"":e,t);const b=.5,k=1,v=1,w=1e9,F=5,C=25e4;async function L(o,e,t){const[a,i]=await f.chainFromRpc(o),c=typeof e=="string"?B.fromSecretKey(T.decode(e)):e;if(t!=null&&t.priorityFee&&t.priorityFee.percentile&&t.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new O(o,i,c,t?.debug??!1,t?.priorityFee??{},t?.retries??F,t?.sendOpts)}class O{constructor(e,t,a,i=!1,c,u=F,l){m(this,"_rpc"),m(this,"_chain"),m(this,"_keypair"),m(this,"_debug"),m(this,"_priorityFee"),m(this,"_maxResubmits"),m(this,"_sendOpts"),this._rpc=e,this._chain=t,this._keypair=a,this._debug=i,this._priorityFee=c,this._maxResubmits=u,this._sendOpts=l,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(e){var t;if(e instanceof P)return!0;if(!(e instanceof E)||!e.message.includes("Transaction simulation failed"))return!1;if(e.message.includes("Blockhash not found"))return!0;const a=(t=e.logs)==null?void 0:t.find(i=>i.startsWith("Program log: Error: "));return a?!!(a.includes("Not enough bytes")||a.includes("Unexpected length of input")):!1}async signAndSend(e){var t;let{blockhash:a,lastValidBlockHeight:i}=await f.latestBlock(this._rpc);const c=[];for(const l of e){const{description:r,transaction:{transaction:n,signers:p}}=l;this._debug&&console.log(`Signing: ${r} for ${this.address()}`);let s;(t=this._priorityFee)!=null&&t.percentile&&this._priorityFee.percentile>0&&(s=await I(this._rpc,n,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&A(n);for(let h=0;h<this._maxResubmits;h++)try{if(y(n)){if(s&&h===0){const g=K.decompile(n.message);g.instructions.push(...s),n.message=g.compileToV0Message()}n.message.recentBlockhash=a,n.sign([this._keypair,...p??[]])}else s&&h===0&&n.add(...s),n.recentBlockhash=a,n.lastValidBlockHeight=i,n.partialSign(this._keypair,...p??[]);this._debug&&console.log("Submitting transactions ");const{signature:d}=await f.sendTxWithRetry(this._rpc,n.serialize(),this._sendOpts);c.push(d);break}catch(d){if(h===this._maxResubmits-1||!this.retryable(d))throw d;this._debug&&console.log(`Failed to send transaction on attempt ${h}, retrying: `,d);const{blockhash:g,lastValidBlockHeight:x}=await f.latestBlock(this._rpc);i=x,a=g}}this._debug&&console.log("Waiting for confirmation for: ",c);const u=(await Promise.all(c.map(async l=>{try{return await this._rpc.confirmTransaction({signature:l,blockhash:a,lastValidBlockHeight:i},this._rpc.commitment)}catch(r){throw console.error("Failed to confirm transaction: ",r),r}}))).filter(l=>l.value.err).map(l=>l.value.err);if(u.length>0)throw new Error(`Failed to confirm transaction: ${u}`);return c}}function A(o){if(y(o)){console.log(o.signatures);const e=o.message,t=e.getAccountKeys();e.compiledInstructions.forEach(a=>{console.log("Program",t.get(a.programIdIndex).toBase58()),console.log("Data: ",S.encode(a.data)),console.log("Keys: ",a.accountKeyIndexes.map(i=>[i,t.get(i).toBase58()]))})}else console.log(o.signatures),console.log(o.feePayer),o.instructions.forEach(e=>{console.log("Program",e.programId.toBase58()),console.log("Data: ",e.data.toString("hex")),console.log("Keys: ",e.keys.map(t=>[t,t.pubkey.toBase58()]))})}async function I(o,e,t=b,a=k,i=v,c=w){const[u,l]=await Promise.all([R(o,e),V(o,e,t,a,i,c)]);return[_.setComputeUnitLimit({units:u}),_.setComputeUnitPrice({microLamports:l})]}async function R(o,e){var t;let a=C;try{const i=await(y(e),o.simulateTransaction(e));i.value.err&&console.error(`Error simulating Solana transaction: ${i.value.err}`),(t=i?.value)!=null&&t.unitsConsumed&&(a=Math.round(i.value.unitsConsumed*1.2))}catch(i){console.error(`Failed to calculate compute unit limit for Solana transaction: ${i}`)}return a}async function V(o,e,t=b,a=k,i=v,c=w){let u=i,l=[];if(y(e)){const r=(await Promise.all(e.message.addressTableLookups.map(s=>o.getAddressLookupTable(s.accountKey)))).map(s=>s.value).filter(s=>s!==null),n=e.message,p=n.getAccountKeys({addressLookupTableAccounts:r??void 0});l=n.compiledInstructions.flatMap(s=>s.accountKeyIndexes).map(s=>n.isAccountWritable(s)?p.get(s):null).filter(s=>s!==null)}else l=e.instructions.flatMap(r=>r.keys).map(r=>r.isWritable?r.pubkey:null).filter(r=>r!==null);try{const r=await o.getRecentPrioritizationFees({lockedWritableAccounts:l});if(r){const n=r.map(s=>s.prioritizationFee).sort((s,h)=>s-h),p=Math.ceil(n.length*t);if(n.length>p){let s=n[p];a>0&&(s*=a),u=Math.max(u,s)}}}catch(r){console.error("Error fetching Solana recent fees",r)}return Math.min(Math.max(u,i),c)}export{L as V,V as W};
