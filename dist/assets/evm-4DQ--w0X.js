const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/Bridge.js","assets/index.js","assets/index.BvO5tclL.css","assets/index-CNq6iUaG.js","assets/index-rJ51Opss.js","assets/index-DIbdsPe6.js"])))=>i.map(i=>d[i]);
import{bu as l}from"./index.js";import{E as D,a as _,b as G,c as F,W as N,P as S,_ as W,A as k,d as R}from"./Bridge.js";var I=Object.defineProperty,T=e=>{throw TypeError(e)},M=(e,t,i)=>t in e?I(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,E=(e,t,i)=>M(e,typeof t!="symbol"?t+"":t,i),x=(e,t,i)=>t.has(e)||T("Cannot "+i),p=(e,t,i)=>(x(e,t,"read from private field"),i?i.call(e):t.get(e)),y=(e,t,i)=>t.has(e)?T("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,i),o=(e,t,i,s)=>(x(e,t,"write to private field"),t.set(e,i),i),V=(e,t,i,s)=>({set _(r){o(e,t,r)},get _(){return p(e,t,s)}}),n,c;const $=class A extends k{constructor(t){super(t.provider),E(this,"signer"),y(this,n),y(this,c),R(this,{signer:t}),o(this,n,null),o(this,c,0)}async getAddress(){return this.signer.getAddress()}connect(t){return new A(this.signer.connect(t))}async getNonce(t){if(t==="pending"){p(this,n)==null&&o(this,n,super.getNonce("pending"));const i=p(this,c);return await p(this,n)+i}return super.getNonce(t)}increment(){V(this,c)._++}reset(){o(this,c,0),o(this,n,null)}async sendTransaction(t){const i=this.getNonce("pending");return this.increment(),t=await this.signer.populateTransaction(t),t.nonce=await i,await this.signer.sendTransaction(t)}signTransaction(t){return this.signer.signTransaction(t)}signMessage(t){return this.signer.signMessage(t)}signTypedData(t,i,s){return this.signer.signTypedData(t,i,s)}};n=new WeakMap,c=new WeakMap;let B=$;async function j(e,t,i){const s=typeof t=="string"?new N(t,e):t,r=i?.chain??(await _.chainFromRpc(e))[1],a=new B(s);if(a.provider===null)try{a.connect(e)}catch(h){console.error("Cannot connect to network for signer",h)}return new z(r,await s.getAddress(),a,i)}class z extends S{constructor(t,i,s,r){super(t,i,s),E(this,"opts"),this.opts=r}chain(){return this._chain}address(){return this._address}async sign(t){var i,s,r,a,h,f;const w=this.chain(),P=[];let d=500000n,u=100000000000n,m=1500000000n,v=100000000n;if(((i=this.opts)==null?void 0:i.overrides)===void 0&&w!=="Celo"){const g=await this._signer.provider.getFeeData();u=g.gasPrice??u,m=g.maxFeePerGas??m,v=g.maxPriorityFeePerGas??v}((s=this.opts)==null?void 0:s.maxGasLimit)!==void 0&&(d=d>((r=this.opts)==null?void 0:r.maxGasLimit)?(a=this.opts)==null?void 0:a.maxGasLimit:d);const C=w==="Oasis"?{gasLimit:d,gasPrice:u,type:0}:{gasLimit:d,maxFeePerGas:m,maxPriorityFeePerGas:v};for(const g of t){const{transaction:b,description:L}=g;(h=this.opts)!=null&&h.debug&&console.log(`Signing: ${L} for ${this.address()}`);const O={...b,...C,from:this.address(),nonce:await this._signer.getNonce(),...(f=this.opts)==null?void 0:f.overrides};P.push(await this._signer.signTransaction(O))}return P}}const q={Address:D,Platform:_,getSigner:j,protocols:{WormholeCore:()=>l(()=>import("./Bridge.js").then(e=>e.dx),__vite__mapDeps([0,1,2])).then(e=>e.dO),TokenBridge:()=>l(()=>import("./index-CNq6iUaG.js"),__vite__mapDeps([3,0,1,2])),PorticoBridge:()=>l(()=>import("./index-rJ51Opss.js"),__vite__mapDeps([4,0,1,2,3])),CircleBridge:()=>l(()=>import("./index-DIbdsPe6.js"),__vite__mapDeps([5,0,1,2,3]))},getChain:(e,t,i)=>new G(t,new _(e,F(e,W,{[t]:i})))};export{q as default};
